<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAABE0AA8AAAAAHWwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY3d1HZY21hcAAAAdgAAACqAAACOvWLi0FjdnQgAAAChAAAABMAAAAgBtX/BGZwZ20AAAKYAAAFkAAAC3CKkZBZZ2FzcAAACCgAAAAIAAAACAAAABBnbHlmAAAIMAAABdQAAAjkYT9TNWhlYWQAAA4EAAAAMwAAADYQ6WvNaGhlYQAADjgAAAAfAAAAJAc6A1pobXR4AAAOWAAAACAAAAA0Kmz/7mxvY2EAAA54AAAAHAAAABwQPBJubWF4cAAADpQAAAAgAAAAIAEHC/NuYW1lAAAOtAAAAYQAAALxhQT4h3Bvc3QAABA4AAAAfgAAAMS3SYh9cHJlcAAAELgAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZHZmnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4Pwz+yMwf9z2KIYg5imAYUZgTJAQDcoQvQAHic7ZHNDYJAFIRnBXf94cDRIiyCKkCpwFCPJ092RcKNDoYKcN4+EmMPvpdvk539zQyAPYBCXEUJhBcCrJ5SQ9YLnLJe4qF5rdb+uWPDngNHTkta101pNyWa8lMhn6xx2dqUnW4q9YOIhAOOeueMSgsR/6ry+P7O5s6xVNg4chBsHUuFnWNJ8uZYwrw7chrsHXkODo7cB0dHOYCTY8kv0VE2WJKD6gOlWjsxAAB4nGNgQAMSEMgc9D8LhAESbAPdAHicrVZpd9NGFB15SZyELCULLWphxMRpsEYmbMGACUGyYyBdnK2VoIsUO+m+8Ynf4F/zZNpz6Dd+Wu8bLySQtOdwmpOjd+fN1czbZRJaktgL65GUmy/F1NYmjew8CemGTctRfCg7eyFlisnfBVEQrZbatx2HREQiULWusEQQ+x5ZmmR86FFGy7akV03KLT3pLlvjQb1V334aOsqxO6GkZjN0aD2yJVUYVaJIpj1S0qZlqPorSSu8v8LMV81QwohOImm8GcbQSN4bZ7TKaDW24yiKbLLcKFIkmuFBFHmU1RLn5IoJDMoHzZDyyqcR5cP8iKzYo5xWsEu20/y+L3mndzk/sV9vUbbkQB/Ijuzg7HQlX4RbW2HctJPtKFQRdtd3QmzZ7FT/Zo/ymkYDtysyvdCMYKl8hRArP6HM/iFZLZxP+ZJHo1qykRNB62VO7Es+gdbjiClxzRhZ0N3RCRHU/ZIzDPaYPh788d4plgsTAngcy3pHJZwIEylhczRJ2jByYCVliyqp9a6YOOV1WsRbwn7t2tGXzmjjUHdiPFsPHVs5UcnxaFKnmUyd2knNoykNopR0JnjMrwMoP6JJXm1jNYmVR9M4ZsaERCICLdxLU0EsO7GkKQTNoxm9uRumuXYtWqTJA/Xco/f05la4udNT2g70s0Z/VqdiOtgL0+lp5C/xadrlIkXp+ukZfkziQdYCMpEtNsOUgwdv/Q7Sy9eWHIXXBtju7fMrqH3WRPCkAfsb0B5P1SkJTIWYVYhWQGKta1mWydWsFqnI1HdDmla+rNMEinIcF8e+jHH9XzMzlpgSvt+J07MjLj1z7UsI0xx8m3U9mtepxXIBcWZ5TqdZlu/rNMfyA53mWZ7X6QhLW6ejLD/UaYHlRzodY3lBC5p038GQizDkAg6QMISlA0NYXoIhLBUMYbkIQ1gWYQjLJRjC8mMYwnIZhrC8rGXV1FNJ49qZWAZsQmBijh65zEXlaiq5VEK7aFRqQ54SbpVUFM+qf2WgXjzyhjmwFkiXyJpfMc6Vj0bl+NYVLW8aO1fAsepvH472OfFS1ouFPwX/1dZUJb1izcOTq/Abhp5sJ6o2qXh0TZfPVT26/l9UVFgL9BtIhVgoyrJscGcihI86nYZqoJVDzGzMPLTrdcuan8P9NzFCFlD9+DcUGgvcg05ZSVnt4KzV19uy3DuDcjgTLEkxN/P6VvgiI7PSfpFZyp6PfB5wBYxKZdhqA60VvNknMQ+Z3iTPBHFbUTZI2tjOBIkNHPOAefOdBCZh6qoN5E7hhg34BWFuwXknXKJ6oyyH7kXs8yik/Fun4kT2qGiMwLPZG2Gv70LKb3EMJDT5pX4MVBWhqRg1FdA0Um6oBl/G2bptQsYO9CMqdsOyrOLDxxb3lZJtGYR8pIjVo6Of1l6iTqrcfmYUl++dvgXBIDUxf3vfdHGQyrtayTJHbQNTtxqVU9eaQ+NVh+rmUfW94+wTOWuabronHnpf06rbwcVcLLD2bQ7SUiYX1PVhhQ2iy8WlUOplNEnvuAcYFhjQ71CKjf+r+th8nitVhdFxJN9O1LfR52AM/A/Yf0f1A9D3Y+hyDS7P95oTn2704WyZrqIX66foNzBrrblZugbc0HQD4iFHrY64yg18pwZxeqS5HOkh4GPdFeIBwCaAxeAT3bWM5lMAo/mMOT7A58xh0GQOgy3mMNhmzhrADnMY7DKHwR5zGHzBnHWAL5nDIGQOg4g5DJ4wJwB4yhwGXzGHwdfMYfANc+4DfMscBjFzGCTMYbCv6dYwzC1e0F2gtkFVoANTT1jcw+JQU2XI/o4Xhv29Qcz+wSCm/qjp9pD6Ey8M9WeDmPqLQUz9VdOdIfU3Xhjq7wYx9Q+DmPpMvxjLZQa/jHyXCgeUXWw+5++J9w/bxUC5AAEAAf//AA94nIVVX2hbZRQ/5/t7893s5ja9f7ouzdZ0TTqz3bRJmogbWya6bG6Cq0VbSV2ddIJjFtfIQHEig80Hda8yUN/0YQz8AyriiyD+xQd92R4HCnaCb3samnpumrpsCsLlfPf7zvedc37nL3CAtc/5W/wQZGA3tOBSY/g+TMjHmwzEoM1Q8+ZjRZY4oJhmBw5/YB6Za0yC5AkhlwA1A1yCBIBOwCII0Cj0U8BAMdUCzq05sKwkP7SlUY6fcJk4Fb/RyE79/6P5hjM/F4aZiXBoeMgzcqQ4Xi1hPqfDLG5FT+lchCVU3lYMyvuwhl1mqndQL0RsuloLywHtthLXI06OblTrhfWVnpSJ5+mwu/JdbtuN3IAnkW0LLMcRwaC7ktrlzridM6kVdyf9uO1UNBByI7JhwtG2sEwab07ORBeilWhqavJCqV0qzZTOl/7ZXQ5TbTcdcFelyGhhRDAQpdqp1FEX3w3cFTc1k9pJQkmm4ySCbSikxRP2QOfN+0tHS5MrpQuTU1Mk5nw0E5Xa0WvrOwDyGax9yB9ma6DAg82wHc43SAGTI4GjBWebOePAERFE8/AHaQpZASSTy8A4WwZiLQMQ82mFKATO0ILicRAoDm9p5P99E5b/fXG+kQYY3TYUuqmERWYoT0u/GNYL2q/4WB3LaVS+VynXsVYIcWw6DkCh3nX1D+VzlYN4LClF5yexSQos8exqZ3KVP+wtrC54u4Nznq6cq+xpMpUUnZ8FUYzE86ud0g28NOIv3Gj5/rmA3ABs7S/ywzFuQ4qyd6QxfNtiQIaEgp3w/entQg4Vcbqa16M5FfpeUB8t1+qeg7mI7cUyOe79wOk86gSxkVec4KPTX69++5x68Yubn5/F+w52z7u08sJX7fZXv8ekT/d2mILJxq6sn+SC6qEJknzLJCxyZEKwWVqYmAPBxBE/9DLeZiWHu7lcr/VytrCRuHojncNuTt9h46tmacmYisnSamdN2bZptcsmSysdVsy1PrOvOzF3xN64Rb937t/og9KHxYdcjIUqFAmIAHGHNzlns+RTPgeUYAQm9DwpNxfxbhhBHPaw3/gfTcXO2L+eJVIx5nsyGkvm9X4/f+bGkH45G0PaSjcMXTjcZyTvi3UdHoCDjQd3IDUVsgwYmUoJK/gp4JJxeRI0MKHZIkgynyIBqBTOUs6rOVCojvjZ4mCQz49ZMlMcp8QoYk6NoBfsxnJtsBohpa8iGJS+ZH7gU7NxME6cmF+t7cO9vB8d3jTWSct0ycW9ranXmolNDwmVkNnxe+8JtoztwS5rKJ0xWS95tQ/1zMYzg69MzUZnNtl1ofNbsml/OJm6f9wjRjpnu2o4MzHzn77IQkRd+1DjwMQ2pqSjGMMhyjrgTbBAKksuUm0iU7hI0aN2wOKOq7WYBSH0HGihj/jkiPxAfmwsEbfYrjMG+j3ij932Db/LV7I/xruNrhnroxjR9HRMb2nTvO0ZXOoHPk8H2ZhDPx93qcE/53sH5np/dkIP7zzhTVKdR/BAY/9ElkkR+A6lJGsqpJ4oQcTxpvBT3Kn58VkaJjgHyPEIws57xkaHh9KuVpDEpJZeMbZ5w/zBHi5NMQ4r5VphsFqID7TyB9eR4pX216c3AHxpdAwoqU9qg0ZJ6yVLKmMSz1iG2z27ifx18NkY0LPx1W/wCc2l5LrznrIsiKsqbmB78A9wIGx4tI8rjihVHJyY9pgMirenVq0yWg7Iw7eogG7ZgYM3qR9959A/fZkg6MnD/exlkmc+jWV4SB15XUR+eqC6l6ZmgPtN9z5JMfik05OV8ljylunJ4J+wA/FUaQSSKotsYsCWqaPBidBLcxkWx7XKFRIb45TGaEhjlF9uUVPqXOtcIwsXbBvfoZXIyRYFdkfnqjExH98xpnPczqzjX/uNdO1Y17Wpi5+6Ts8BXtjVFasp9KZ1mOiNbH65c5w6HgmyF2jFCZywM8mWjRc7T5Pmt0lRy7Y71+jYbpGyvwG4sH0XeJxjYGRgYADiwBB/53h+m68M3MwvgCIM1z5N/g6j///9v5H5BbMnkMvBwAQSBQCIcA9gAHicY2BkYGAO+p8FJF/8//v/F/MLBqAICuAFALYQB5kAeJxjfsHAwLwAiCNB+P9fbJjJmoGBMRUo/wKCAfO2EnQAAAAAANoBXgGcAgICVALaA1IDvAPkBAYEPARyAAEAAAANAF0ABAAAAAAAAgAUACQAcwAAAG4LcAAAAAB4nHWRzWrCQBSFT+pPqUIXLXTTzayKUohGKIibCoLuhbrrYtTRxCYZmYyKyz5Fd32HvlDfoO/QkziIFJtw9bvnnpl7ZwLgBt/wcHieGAf2UGd24Atcou+4RH3kuEweO66QXx1XyaHjGh6ROa7jFp/cwStfMVvhy7GHO+/e8QWuvcBxifqz4zL5xXGF/Oa4Sn53XMPE+3Bcx4P3M9DrvYmWoRWNQVN02kFXTPdCU4pSGQu5saE2meiLhU6timPtz3SSs9ypTCdqrJabWJoT5QQnymSRTkXgt0/UkUqVkVbN807ZdtmxdiEWRidi6HqItdErNbN+aO2612qd9sYAGmvsYRBhyUu0EGhQbfK/gzYCdElTOgSdB1eEFBIxFYkNV4RFJWPeZyyYpVQVHTHZx4y/yVGX2LGWFZri51TccUOn5B7nPefVCSPvGhVVwUl9znveO2KkhV8Wk82PZ8qwZf8OVcu1+fSmWCMw/HMOwXvKaysqM+p+cVuWag8tvv+c+xdd+4+teJxtjUEOwiAURJla24KliQfhUA2g/Sl+CKXx+loNrpzVezOLEY34Ron/0WhwQoszOvQYIKFwwQiNSbSBeO2SZ0tBP4j3zVjKNng32ZmtD1VVXCuOiw/pJ8S3WOU6l+K5UOTaDC4+2TjKMtN9KQf1ezLx/Sg/00FCvABHhjDjAAB4nGPw3sFwIihiIyNjX+QGxp0cDBwMyQUbGVidNjEwMmiBGJu5mBg5ICw+BjCLzWkX0wGgNCeQze60i8EBwmZmcNmowtgRGLHBoSNiI3OKy0Y1EG8XRwMDI4tDR3JIBEhJJBBs5mFi5NHawfi/dQNL70YmBhcADHYj9AAA) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable,
.markdown-body .highlighttable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr,
.markdown-body .highlighttable {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite,
.markdown-body .highlighttable pre,
.markdown-body .highlighttable div.highlight {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td,
.markdown-body .highlighttable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite,
.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*GitHub*/
.highlight {background-color:#fff;color:#333333;}
.highlight .hll {background-color:#ffffcc;}
.highlight .c{color:#999988;font-style:italic}
.highlight .err{color:#a61717;background-color:#e3d2d2}
.highlight .k{font-weight:bold}
.highlight .o{font-weight:bold}
.highlight .cm{color:#999988;font-style:italic}
.highlight .cp{color:#999999;font-weight:bold}
.highlight .c1{color:#999988;font-style:italic}
.highlight .cs{color:#999999;font-weight:bold;font-style:italic}
.highlight .gd{color:#000000;background-color:#ffdddd}
.highlight .ge{font-style:italic}
.highlight .gr{color:#aa0000}
.highlight .gh{color:#999999}
.highlight .gi{color:#000000;background-color:#ddffdd}
.highlight .go{color:#888888}
.highlight .gp{color:#555555}
.highlight .gs{font-weight:bold}
.highlight .gu{color:#800080;font-weight:bold}
.highlight .gt{color:#aa0000}
.highlight .kc{font-weight:bold}
.highlight .kd{font-weight:bold}
.highlight .kn{font-weight:bold}
.highlight .kp{font-weight:bold}
.highlight .kr{font-weight:bold}
.highlight .kt{color:#445588;font-weight:bold}
.highlight .m{color:#009999}
.highlight .s{color:#dd1144}
.highlight .n{color:#333333}
.highlight .na{color:teal}
.highlight .nb{color:#0086b3}
.highlight .nc{color:#445588;font-weight:bold}
.highlight .no{color:teal}
.highlight .ni{color:purple}
.highlight .ne{color:#990000;font-weight:bold}
.highlight .nf{color:#990000;font-weight:bold}
.highlight .nn{color:#555555}
.highlight .nt{color:navy}
.highlight .nv{color:teal}
.highlight .ow{font-weight:bold}
.highlight .w{color:#bbbbbb}
.highlight .mf{color:#009999}
.highlight .mh{color:#009999}
.highlight .mi{color:#009999}
.highlight .mo{color:#009999}
.highlight .sb{color:#dd1144}
.highlight .sc{color:#dd1144}
.highlight .sd{color:#dd1144}
.highlight .s2{color:#dd1144}
.highlight .se{color:#dd1144}
.highlight .sh{color:#dd1144}
.highlight .si{color:#dd1144}
.highlight .sx{color:#dd1144}
.highlight .sr{color:#009926}
.highlight .s1{color:#dd1144}
.highlight .ss{color:#990073}
.highlight .bp{color:#999999}
.highlight .vc{color:teal}
.highlight .vg{color:teal}
.highlight .vi{color:teal}
.highlight .il{color:#009999}
.highlight .gc{color:#999;background-color:#EAF2F5}
</style><title>cd每天学一点点</title></head><body><article class="markdown-body"><blockquote>
<p>修改目录为左边框方法<a href="https://blog.csdn.net/zjiang1994/article/details/52250363" target="_blank">https://blog.csdn.net/zjiang1994/article/details/52250363</a></p>
</blockquote>
<div class="toc">
<ul>
<li><a href="#202061">2020/6/1</a><ul>
<li><a href="#_1">前端路由</a><ul>
<li><a href="#hash">hash模式</a></li>
<li><a href="#history">history模式</a></li>
<li><a href="#_2">区别</a></li>
<li><a href="#_3">参考链接</a></li>
</ul>
</li>
<li><a href="#postget">post和get的区别</a><ul>
<li><a href="#_4">参考链接</a></li>
</ul>
</li>
<li><a href="#vue">vue组件通信</a><ul>
<li><a href="#_5">父子组件通信</a></li>
<li><a href="#_6">兄弟组件通信</a></li>
<li><a href="#attrslisteners">$attrs/$listeners</a></li>
<li><a href="#provideinject">provide/inject</a></li>
<li><a href="#_7">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202062">2020/6/2</a><ul>
<li><a href="#vueaxios">vue中axios封装</a><ul>
<li><a href="#_8">参考链接</a></li>
</ul>
</li>
<li><a href="#_9">克隆/拷贝</a><ul>
<li><a href="#_10">浅拷贝</a></li>
<li><a href="#_11">深拷贝</a></li>
<li><a href="#_12">参考链接</a></li>
</ul>
</li>
<li><a href="#spampa">SPA（单页面应用）和MPA（多页面应用）</a><ul>
<li><a href="#spa">SPA</a></li>
<li><a href="#mpa">MPA</a></li>
<li><a href="#_13">参考链接</a></li>
</ul>
</li>
<li><a href="#vue_1">vue三要素</a><ul>
<li><a href="#1-render">1、把模板解析为 render 函数：</a></li>
<li><a href="#2">2、响应式开始监听：</a></li>
<li><a href="#3">3、首次渲染，显示页面且绑定依赖</a></li>
<li><a href="#4datarender">4、data属性变化，触发render</a></li>
<li><a href="#_14">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202063">2020/6/3</a><ul>
<li><a href="#domvirtual-dom">虚拟DOM（virtual DOM）</a><ul>
<li><a href="#domapi">虚拟DOM的核心API</a></li>
<li><a href="#diff">diff算法</a></li>
<li><a href="#_15">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202064">2020/6/4</a><ul>
<li><a href="#vuex">vuex</a><ul>
<li><a href="#vuex_1">vuex的组成</a></li>
<li><a href="#_16">工作流程</a></li>
<li><a href="#_17">应用场景</a></li>
<li><a href="#_18">参考链接</a></li>
</ul>
</li>
<li><a href="#vuevue-router">vue路由（vue-router）</a><ul>
<li><a href="#_19">组件</a></li>
<li><a href="#_20">路由分类</a></li>
<li><a href="#_21">路由对象</a></li>
<li><a href="#_22">路由的钩子函数（导航守卫）</a></li>
<li><a href="#_23">重定向和别名</a></li>
<li><a href="#_24">常见问题</a></li>
<li><a href="#_25">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202065">2020/6/5</a><ul>
<li><a href="#mixin">Mixin（混入）</a><ul>
<li><a href="#_26">使用场景</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020610">2020/6/10</a><ul>
<li><a href="#vue_2">vue自定义指令（项目中实践用到的）</a><ul>
<li><a href="#_27">使用方式</a></li>
<li><a href="#_28">指令定义对象的钩子函数</a></li>
<li><a href="#_29">钩子函数的参数</a></li>
<li><a href="#_30">使用实例代码</a></li>
<li><a href="#_31">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020611">2020/6/11</a><ul>
<li><a href="#_32">原型、原型链</a><ul>
<li><a href="#new">new运算符的缺点</a></li>
<li><a href="#prototype">protoType属性</a></li>
<li><a href="#_33">原型链</a></li>
<li><a href="#_34">继承</a></li>
<li><a href="#_35">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020618">2020/6/18</a><ul>
<li><a href="#vue-filter">vue 自定义过滤器（filter）</a><ul>
<li><a href="#_36">组件过滤器和全局过滤器</a></li>
<li><a href="#_37">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020622">2020/6/22</a><ul>
<li><a href="#css-dispalypositionfloat">CSS布局&ndash;dispaly、position、float</a><ul>
<li><a href="#-position">定位&ndash;position</a></li>
<li><a href="#_38">浮动</a></li>
<li><a href="#_39">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020623">2020/6/23</a><ul>
<li><a href="#inline-blockfloat">inline-block和float</a><ul>
<li><a href="#_40">区别</a></li>
<li><a href="#_41">参考链接</a></li>
</ul>
</li>
<li><a href="#cookiesessiontoken">cookie、session、token（令牌）</a><ul>
<li><a href="#cookie">cookie</a></li>
<li><a href="#session">session</a></li>
<li><a href="#cookiesession">cookie与session的区别</a></li>
<li><a href="#token">token</a></li>
<li><a href="#sessiontoken">分布式情况下的session和token</a></li>
<li><a href="#jwtjson-web-token">JWT（Json Web Token）</a></li>
<li><a href="#_42">总结</a></li>
<li><a href="#_43">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020628">2020/6/28</a><ul>
<li><a href="#_44">前端跨域</a><ul>
<li><a href="#_45">浏览器同源策略</a></li>
<li><a href="#_46">同域、父域子域</a></li>
<li><a href="#_47">跨域解决办法</a><ul>
<li><a href="#cors">CORS（跨域资源共享）</a></li>
<li><a href="#jsonp">JSONP 跨域</a></li>
<li><a href="#ping">图像 Ping 跨域</a></li>
<li><a href="#_48">服务器代理</a></li>
<li><a href="#documentdomain">document.domain 跨域</a></li>
<li><a href="#documentname">document.name 跨域</a></li>
<li><a href="#locationhash">location.hash 跨域</a></li>
<li><a href="#postmessage">postMessage 跨域</a></li>
</ul>
</li>
<li><a href="#_49">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020629">2020/6/29</a><ul>
<li><a href="#http">HTTP缓存机制</a><ul>
<li><a href="#_50">强制缓存</a></li>
<li><a href="#_51">协商缓存(对比缓存)</a></li>
<li><a href="#_52">缓存的优点</a></li>
<li><a href="#_53">不同刷新键执行缓存</a></li>
<li><a href="#_54">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020630">2020/6/30</a><ul>
<li><a href="#_55">函数防抖与节流</a><ul>
<li><a href="#debounce">防抖（debounce）</a></li>
<li><a href="#throttle">节流（throttle）</a></li>
<li><a href="#_56">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202071">2020/7/1</a><ul>
<li><a href="#url">输入URL之后的过程</a><ul>
<li><a href="#dns">DNS解析</a></li>
<li><a href="#tcp">TCP链接、三次握手</a></li>
<li><a href="#http_1">发送HTTP请求</a></li>
<li><a href="#http_2">服务器处理请求并返回HTTP报文</a></li>
<li><a href="#_57">浏览器解析渲染页面</a></li>
<li><a href="#_58">参考链接</a></li>
</ul>
</li>
<li><a href="#_59">浏览器的回流与重绘</a><ul>
<li><a href="#reflow">回流(Reflow)</a></li>
<li><a href="#repaint">重绘 (Repaint)</a></li>
<li><a href="#_60">性能影响和避免</a></li>
<li><a href="#_61">参考链接</a></li>
</ul>
</li>
<li><a href="#tcp_1">TCP三次握手、四次挥手</a><ul>
<li><a href="#_62">三次握手</a></li>
<li><a href="#_63">四次挥手</a></li>
<li><a href="#_64">问题</a></li>
<li><a href="#_65">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202072">2020/7/2</a><ul>
<li><a href="#httphttps">HTTP和HTTPS</a><ul>
<li><a href="#_66">计算机通信原理</a></li>
<li><a href="#http_3">HTTP</a></li>
<li><a href="#https">HTTPS</a><ul>
<li><a href="#tlsssl">TLS/SSL工作原理</a></li>
<li><a href="#pki">PKI体系</a></li>
</ul>
</li>
<li><a href="#https_1">HTTPS性能损耗与优化</a></li>
<li><a href="#_67">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202073">2020/7/3</a><ul>
<li><a href="#http10http11-http20">HTTP1.0、HTTP1.1 和 HTTP2.0</a><ul>
<li><a href="#http_4">HTTP的基本优化</a></li>
<li><a href="#http10http11">HTTP1.0和HTTP1.1的区别</a></li>
<li><a href="#http1011">HTTP1.0和1.1现存的一些问题</a></li>
<li><a href="#spdyhttp1x">SPDY:HTTP1.x的优化</a></li>
<li><a href="#http20">HTTP2.0的新特性</a></li>
<li><a href="#_68">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202076">2020/7/6</a><ul>
<li><a href="#sessionstorage-localstorage">sessionStorage 和 localStorage</a></li>
<li><a href="#webpackvue-cli-proxytable">webpack/Vue-cli 利用proxyTable跨域</a><ul>
<li><a href="#_69">参考链接</a></li>
</ul>
</li>
<li><a href="#nodejsrequirepathresolve">nodejs的require和path.resolve()</a><ul>
<li><a href="#node-require">node require</a></li>
<li><a href="#nodepathresolve__dirnamesrc">Node的path.resolve(__dirname，&rsquo;./src&rsquo;)</a></li>
<li><a href="#_70">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202078">2020/7/8</a><ul>
<li><a href="#ajaxjquery-ajax-axios-fetch">ajax、jquery ajax、 axios、 fetch</a><ul>
<li><a href="#ajax">ajax</a></li>
<li><a href="#jquery-ajax">Jquery Ajax</a></li>
<li><a href="#axios">axios</a></li>
<li><a href="#fetch">fetch</a></li>
<li><a href="#_71">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202079">2020/7/9</a><ul>
<li><a href="#javascript">javaScript闭包</a><ul>
<li><a href="#_72">作用域与词法作用域</a></li>
<li><a href="#_73">闭包</a></li>
<li><a href="#_74">参考链接</a></li>
</ul>
</li>
<li><a href="#curry">函数柯里化（curry）</a><ul>
<li><a href="#_75">柯里化</a></li>
<li><a href="#_76">反柯里化</a></li>
<li><a href="#_77">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020713">2020/7/13</a><ul>
<li><a href="#vue_3">vue修饰符</a><ul>
<li><a href="#_78">表单修饰符</a></li>
<li><a href="#_79">事件修饰符</a></li>
<li><a href="#_80">鼠标按钮修饰符</a></li>
<li><a href="#_81">键盘修饰符</a></li>
<li><a href="#v-bind">v-bind 修饰符</a></li>
<li><a href="#_82">参考链接</a></li>
</ul>
</li>
<li><a href="#vue-data">vue data函数（为什么）</a></li>
</ul>
</li>
<li><a href="#2020723">2020/7/23</a><ul>
<li><a href="#jsattributeproperty">js中的attribute和property</a><ul>
<li><a href="#_83">参考链接</a></li>
</ul>
</li>
<li><a href="#css">CSS选择器</a><ul>
<li><a href="#css_1">CSS伪类</a></li>
<li><a href="#css_2">CSS伪元素</a></li>
<li><a href="#_84">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020727">2020/7/27</a><ul>
<li><a href="#es6-symbol">es6 Symbol</a><ul>
<li><a href="#symbol">共享Symbol</a></li>
<li><a href="#_85">属性检索</a></li>
<li><a href="#_86">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020729">2020/7/29</a><ul>
<li><a href="#vueobjectdefinepropertyproxy">vue数据双向绑定：Object.defineProperty和Proxy</a><ul>
<li><a href="#objectdefineproperty">Object.defineProperty实现双向绑定</a></li>
<li><a href="#proxy">Proxy实现双向绑定</a><ul>
<li><a href="#reflect">reflect</a></li>
</ul>
</li>
<li><a href="#proxy-objectdefineproperty">Proxy 与 Object.defineProperty 比较</a></li>
<li><a href="#_87">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020730">2020/7/30</a><ul>
<li><a href="#_88">浏览器的兼容性问题</a><ul>
<li><a href="#_89">参考链接</a></li>
</ul>
</li>
<li><a href="#css-hack">css hack</a><ul>
<li><a href="#_90">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020731">2020/7/31</a><ul>
<li><a href="#html5">HTML5</a><ul>
<li><a href="#_91">新特性</a></li>
<li><a href="#_92">元素变动</a></li>
<li><a href="#_93">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202083">2020/8/3</a><ul>
<li><a href="#babel">Babel转码器</a><ul>
<li><a href="#babel-polyfill">babel-polyfill</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2020812">2020/8/12</a><ul>
<li><a href="#js">JS事件的浏览器兼容处理</a></li>
</ul>
</li>
<li><a href="#2021129">2021/1/29</a><ul>
<li><a href="#imagejpegcontent-type-imagegif">后台返回 image/jpeg（content-type: image/gif）类型数据，怎么展示图片</a><ul>
<li><a href="#_94">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#202124">2021/2/4</a><ul>
<li><a href="#callapplaybind">call,applay,bind</a><ul>
<li><a href="#call-applay">call &amp; applay</a></li>
<li><a href="#bind">bind</a></li>
<li><a href="#_95">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2021223">2021/2/23</a><ul>
<li><a href="#flex">flex布局</a><ul>
<li><a href="#flex_1">flex布局是什么</a></li>
<li><a href="#_96">容器属性</a></li>
<li><a href="#_97">项目属性</a></li>
<li><a href="#_98">参考链接</a></li>
</ul>
</li>
<li><a href="#bfc">BFC(块级格式化上下文)</a><ul>
<li><a href="#bfc_1">BFC布局规则特性</a></li>
<li><a href="#bfc_2">BFC的主要用途</a></li>
<li><a href="#_99">参考链接</a></li>
</ul>
</li>
<li><a href="#_100">前端鉴权</a><ul>
<li><a href="#_101">常见的几种鉴权方式：</a><ul>
<li><a href="#http-basic-authentication">HTTP Basic Authentication</a></li>
<li><a href="#session-cookie">session-cookie</a></li>
<li><a href="#token_1">Token 验证</a></li>
<li><a href="#oauth">OAuth(开放授权)</a></li>
</ul>
</li>
<li><a href="#vue_4">vue项目前端鉴权方式常用的有以下三种：</a></li>
<li><a href="#_102">按钮鉴权</a></li>
<li><a href="#_103">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2021224">2021/2/24</a><ul>
<li><a href="#domcontentloaded-load">DOMContentLoaded 与 load事件</a><ul>
<li><a href="#domcontentloaded">DOMContentLoaded</a></li>
<li><a href="#load">load</a></li>
<li><a href="#cssjs">为什么一再强调将css放在头部，将js文件放在尾部？</a></li>
<li><a href="#_104">参考链接</a></li>
</ul>
</li>
<li><a href="#vuevue-lazyload">vue图片懒加载（vue-lazyload）</a><ul>
<li><a href="#_105">可优化内容</a></li>
<li><a href="#_106">参考链接</a></li>
</ul>
</li>
<li><a href="#vue3">vue项目实现路由按需加载(路由懒加载)的3种方式</a><ul>
<li><a href="#_107">异步加载</a></li>
<li><a href="#import">路由懒加载(使用import)</a></li>
<li><a href="#webpackrequireensure">webpack提供的require.ensure()</a></li>
<li><a href="#_108">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2021225">2021/2/25</a><ul>
<li><a href="#event-loop">event loop(事件循环)</a><ul>
<li><a href="#_109">执行栈与事件队列</a></li>
<li><a href="#micro-taskmacro-task">微任务（micro task）和宏任务（macro task）</a></li>
<li><a href="#node-event-loop">Node与浏览器的 Event Loop 差异</a></li>
<li><a href="#_110">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2021311">2021/3/11(中联重科)</a><ul>
<li><a href="#promise">promise</a></li>
<li><a href="#keep-alive">keep-alive</a><ul>
<li><a href="#props">Props</a></li>
<li><a href="#activateddeactivated">钩子函数（activated，deactivated）</a></li>
</ul>
</li>
<li><a href="#ononceoffemit">$on,$once,$off,$emit</a><ul>
<li><a href="#onoffemit">$on,$off,$emit</a></li>
<li><a href="#once">$once</a></li>
</ul>
</li>
<li><a href="#vue2vue3">vue2,vue3的区别</a></li>
</ul>
</li>
<li><a href="#2020316">2020/3/16</a><ul>
<li><a href="#js_1">js数据类型判断</a><ul>
<li><a href="#typeof">typeof</a></li>
<li><a href="#instanceof">instanceof</a></li>
<li><a href="#objectprototypetostringcall">Object.prototype.toString.call()</a></li>
<li><a href="#_111">参考链接</a></li>
</ul>
</li>
<li><a href="#_112">日常问题（长期更新）</a><ul>
<li><a href="#_113">常见</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="202061">2020/6/1<a class="headerlink" href="#202061" title="Permanent link"></a></h2>
<h3 id="_1">前端路由<a class="headerlink" href="#_1" title="Permanent link"></a></h3>
<p>为了构建 SPA（单页面应用），需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— 改变视图的同时不会向后端发出请求。<br />
两种模式：hash和history<br />
hash 模式和 history 模式都属于浏览器自身的属性</p>
<h4 id="hash">hash模式<a class="headerlink" href="#hash" title="Permanent link"></a></h4>
<p>url后面带#号，如http://<a href="http://www.abc.com/#/hello">www.abc.com/#/hello</a><br />
路由的哈希模式其实是利用了window可以监听onhashchange事件<br />
通过window.location.hash 获取地址上的hash值<br />
改变#后面的内容不会引起页面重新刷新，但是会有历史记录</p>
<h4 id="history">history模式<a class="headerlink" href="#history" title="Permanent link"></a></h4>
<p>url后面不带#号<br />
需配置mode: &lsquo;history&rsquo;<br />
利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。<br />
history模式不怕前进不怕后退怕刷新，刷新会发送请求，当后端没有配置对应的请求路径资源时，会出现404，为了应对这种情况，服务端可将不存在路径设置重定向到入口文件（index.html）</p>
<h4 id="_2">区别<a class="headerlink" href="#_2" title="Permanent link"></a></h4>
<p>hash模式有#，不好看；history模式无#，好看<br />
回车刷新时：hash模式可以加载到hash值对应页面，history模式可能会出现404情况（history模式的劣势）<br />
浏览器支持：hash模式支持低版本浏览器和IE浏览器；history是HTML5新推出的API</p>
<h4 id="_3">参考链接<a class="headerlink" href="#_3" title="Permanent link"></a></h4>
<p><a href="https://blog.csdn.net/fifteen718/article/details/82529433" target="_blank">https://blog.csdn.net/fifteen718/article/details/82529433</a><br />
<a href="https://juejin.im/post/5b4ca076f265da0f900e0a7d" target="_blank">https://juejin.im/post/5b4ca076f265da0f900e0a7d</a><br />
<a href="https://juejin.im/post/5b31a4f76fb9a00e90018cee" target="_blank">https://juejin.im/post/5b31a4f76fb9a00e90018cee</a></p>
<h3 id="postget">post和get的区别<a class="headerlink" href="#postget" title="Permanent link"></a></h3>
<ul>
<li>GET参数通过URL传递，POST放在Request body中  </li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求  </li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息  </li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以  </li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li>
</ul>
<h4 id="_4">参考链接<a class="headerlink" href="#_4" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank">https://www.cnblogs.com/logsharing/p/8448446.html</a></p>
<h3 id="vue">vue组件通信<a class="headerlink" href="#vue" title="Permanent link"></a></h3>
<h4 id="_5">父子组件通信<a class="headerlink" href="#_5" title="Permanent link"></a></h4>
<ul>
<li>父组件传值给子组件：props  </li>
<li>子组件传值给父组件：通过事件形式,this.$emit</li>
<li>$parent / $children与 ref</li>
</ul>
<h4 id="_6">兄弟组件通信<a class="headerlink" href="#_6" title="Permanent link"></a></h4>
<p>event bus：$on,$emit,$off(销毁)
通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级</p>
<h4 id="attrslisteners">$attrs/$listeners<a class="headerlink" href="#attrslisteners" title="Permanent link"></a></h4>
<p>多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法----$attrs/$listeners<br />
$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&rdquo;$attrs&rdquo; 传入内部组件。通常配合 inheritAttrs 选项一起使用。</p>
<h4 id="provideinject">provide/inject<a class="headerlink" href="#provideinject" title="Permanent link"></a></h4>
<p>Vue2.2.0新增API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效<br />
祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量<br />
它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系<br />
provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的  </p>
<h4 id="_7">参考链接<a class="headerlink" href="#_7" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5cde0b43f265da03867e78d3" target="_blank">https://juejin.im/post/5cde0b43f265da03867e78d3</a>  </p>
<h2 id="202062">2020/6/2<a class="headerlink" href="#202062" title="Permanent link"></a></h2>
<h3 id="vueaxios">vue中axios封装<a class="headerlink" href="#vueaxios" title="Permanent link"></a></h3>
<p>在vue项目中，和后台交互获取数据这块，通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中<br />
优点：拦截请求和响应、取消请求、转换json、客户端防御XSRF等  </p>
<ul>
<li>设置请求超时： timeout  </li>
<li>请求拦截： axios.interceptors.request.use  </li>
<li>响应拦截： axios.interceptors.response.use  </li>
<li>封装get方法和post方法：post需要设置请求头，默认：<br />
axios.defaults.headers.post[&lsquo;Content-Type&rsquo;] = &lsquo;application/x-www-form-urlencoded;charset=UTF-8&rsquo;;</li>
</ul>
<h4 id="_8">参考链接<a class="headerlink" href="#_8" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5b55c118f265da0f6f1aa354" target="_blank">https://juejin.im/post/5b55c118f265da0f6f1aa354</a></p>
<h3 id="_9">克隆/拷贝<a class="headerlink" href="#_9" title="Permanent link"></a></h3>
<p>深拷贝和浅拷贝与原数据并不指向同一对象</p>
<h4 id="_10">浅拷贝<a class="headerlink" href="#_10" title="Permanent link"></a></h4>
<p>浅拷贝之所以被称为浅拷贝，是因为对象只会被拷贝最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存<br />
浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据<br />
Object.assign(): 一层深克隆，二层浅克隆</p>
<h4 id="_11">深拷贝<a class="headerlink" href="#_11" title="Permanent link"></a></h4>
<p>在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝<br />
深拷贝是对对象以及对象的所有子对象进行拷贝<br />
JSON.parse：可实现深拷贝，缺点  </p>
<ul>
<li>无法复制函数</li>
<li>无法复制正则对象</li>
<li>构造函数指向错误：会抛弃对象的constructor,所有的构造函数会指向Object</li>
</ul>
<h4 id="_12">参考链接<a class="headerlink" href="#_12" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5abb55ee6fb9a028e33b7e0a" target="_blank">https://juejin.im/post/5abb55ee6fb9a028e33b7e0a</a><br />
<a href="https://juejin.im/post/59ac1c4ef265da248e75892b#heading-11" target="_blank">https://juejin.im/post/59ac1c4ef265da248e75892b#heading-11</a></p>
<h3 id="spampa">SPA（单页面应用）和MPA（多页面应用）<a class="headerlink" href="#spampa" title="Permanent link"></a></h3>
<h4 id="spa">SPA<a class="headerlink" href="#spa" title="Permanent link"></a></h4>
<p>第一次进入页面时会请求一个html文件，刷新清除一下，切换到其他组件，此时路径也相应变化，但是并没有新的html文件请求，页面内容却变化了  </p>
<ul>
<li>页面跳转： js渲染</li>
<li>优点： 页面切换快：页面每次切换跳转时，不需要处理html文件的请求，节约了HTTP发送时延</li>
<li>缺点： <ul>
<li>首屏时间稍慢：首屏时需要请求一次html，同时还要发送一次js请求</li>
<li>SEO差：搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名  </li>
</ul>
</li>
</ul>
<p>使用vue：服务端渲染技术（SSR）可解决缺点</p>
<h4 id="mpa">MPA<a class="headerlink" href="#mpa" title="Permanent link"></a></h4>
<p>每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用  </p>
<ul>
<li>页面跳转： 返回HTML</li>
<li>优点： <ul>
<li>首屏时间快：访问页面的时候，服务器返回一个html，只经历了一个HTTP请求</li>
<li>SEO效果好：搜索引擎是可以识别html内容的，每个页面所有的内容都放在html中，所以SEO排名效果好</li>
</ul>
</li>
<li>缺点： 切换慢：每次跳转都需要发送一个HTTP请求，如果网络状态不好，在页面间来回跳转时，就会发生明显的卡顿，影响用户体验</li>
</ul>
<h4 id="_13">参考链接<a class="headerlink" href="#_13" title="Permanent link"></a></h4>
<p><a href="https://www.jianshu.com/p/a02eb15d2d70" target="_blank">https://www.jianshu.com/p/a02eb15d2d70</a></p>
<h3 id="vue_1">vue三要素<a class="headerlink" href="#vue_1" title="Permanent link"></a></h3>
<p>模板引擎、响应式、渲染  </p>
<ul>
<li>响应式：vue如何监听到data中每个属性的变化？</li>
<li>模板引擎：vue的模板如何被解析，指令如何处理？</li>
<li>渲染：vue的模板如何被渲染成html，以及渲染过程？</li>
</ul>
<p>Vue 实现流程：  </p>
<h4 id="1-render">1、把模板解析为 render 函数：<a class="headerlink" href="#1-render" title="Permanent link"></a></h4>
<ul>
<li>Vue模板：<ul>
<li>本质是字符串；</li>
<li>有逻辑如 v-if v-for 等，模板转换成 js后（render 函数 ）通过js来实现逻辑；</li>
<li>与 html 格式很像，但有很大区别，html 是静态的， Vue 的模板是动态的；</li>
<li>最终 Vue 的模板都要通过 js 转换为 html 来显示  </li>
</ul>
</li>
<li>vue中如何解析模板：<ul>
<li>第一步是将模板通过 parse 函数解析成 AST（抽象语法树）</li>
<li>第二步优化AST（检测出不需要更改的DOM的纯静态子树）</li>
<li>第三步根据优化后的抽象语法树生成包含渲染函数字符串的对象  </li>
</ul>
</li>
</ul>
<p>模板中的所有内容都包含在了 render 函数中</p>
<h4 id="2">2、响应式开始监听：<a class="headerlink" href="#2" title="Permanent link"></a></h4>
<ul>
<li>Object.defineProperty(双向数据绑定)：缺点 【为什么Vue3.x 升级使用 Proxy 取代 Object.defineProperty】<ul>
<li>Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应(可用$set添加）；</li>
<li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。</li>
<li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性</li>
</ul>
</li>
<li>将data的属性代理到vm上</li>
</ul>
<h4 id="3">3、首次渲染，显示页面且绑定依赖<a class="headerlink" href="#3" title="Permanent link"></a></h4>
<p>虚拟dom中的patch函数(第一种用法) patch(el, vnode)  </p>
<h4 id="4datarender">4、data属性变化，触发render<a class="headerlink" href="#4datarender" title="Permanent link"></a></h4>
<ul>
<li>修改属性，被响应式的set监听到</li>
<li>set中执行 updataComponent （ 异步 ）</li>
<li>updataComponent重新执行 vm.render()</li>
<li>生成的vnode和prev Vnode，<strong>通过patch进行比较渲染到html 中</strong>（虚拟dom中的patch函数(第二种用法) patch(preVnode, newVnode)）</li>
</ul>
<h4 id="_14">参考链接<a class="headerlink" href="#_14" title="Permanent link"></a></h4>
<p><a href="https://blog.csdn.net/weixin_33709364/article/details/88010302" target="_blank">https://blog.csdn.net/weixin_33709364/article/details/88010302</a><br />
<a href="https://blog.csdn.net/webFrontEndDev/article/details/102702402" target="_blank">https://blog.csdn.net/webFrontEndDev/article/details/102702402</a><br />
<a href="https://juejin.im/post/5e7ae687f265da57424bb691#heading-11" target="_blank">https://juejin.im/post/5e7ae687f265da57424bb691#heading-11</a></p>
<h2 id="202063">2020/6/3<a class="headerlink" href="#202063" title="Permanent link"></a></h2>
<h3 id="domvirtual-dom">虚拟DOM（virtual DOM）<a class="headerlink" href="#domvirtual-dom" title="Permanent link"></a></h3>
<p>用 JS 模拟 DOM 结构  </p>
<ul>
<li>操作真实DOM代价昂贵，如：在一次操作中，需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。频繁操作还是会出现页面卡顿，影响用户体验</li>
<li>虚拟DOM可提高浏览器性能：若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量</li>
<li>JS对象模拟DOM节点的好处：页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制</li>
</ul>
<h4 id="domapi">虚拟DOM的核心API<a class="headerlink" href="#domapi" title="Permanent link"></a></h4>
<ul>
<li>h函数（将真实dom映射成虚拟节点）<br />
    h(&lt;标签名&gt;，{属性}，[children])//含有子节点的<br />
    h(&lt;标签名&gt;，{属性}，&rsquo;text&rsquo;])//没有子节点，只有文本，如p标签</li>
<li>patch函数（通过对比新旧虚拟节点，找出差异（diff算法），把变化更新到真实dom中）<br />
    patch(container, vnode)//初次渲染<br />
    patch(oldVnode, newVnode); //re-render</li>
</ul>
<h4 id="diff">diff算法<a class="headerlink" href="#diff" title="Permanent link"></a></h4>
<p>找出本次DOM必须更新的节点来更新，其它的不更新，这个“找出”的过程，就需要diff算法<br />
使用diff算法来比较旧VNode及新的VNode之间的差异然后执行Patch Operation或者叫 Patch函数来高效更新 Dom 节点<br />
实现过程：  </p>
<ul>
<li>patch（container，vnode）：核心逻辑createElement</li>
<li>patch（vnode，newVnode）：核心逻辑updataChildren</li>
</ul>
<h4 id="_15">参考链接<a class="headerlink" href="#_15" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/charliePU/p/10791165.html" target="_blank">https://www.cnblogs.com/charliePU/p/10791165.html</a><br />
<a href="https://www.jianshu.com/p/af0b398602bc" target="_blank">https://www.jianshu.com/p/af0b398602bc</a></p>
<h2 id="202064">2020/6/4<a class="headerlink" href="#202064" title="Permanent link"></a></h2>
<h3 id="vuex">vuex<a class="headerlink" href="#vuex" title="Permanent link"></a></h3>
<p>Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化<br />
把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为<br />
Vuex和单纯的全局对象的不同：  </p>
<ul>
<li>Vuex 的状态存储是响应式的</li>
<li>不能直接改变store中的状态，只能通过mutation或者actions（异步）改变store中的状态</li>
</ul>
<h4 id="vuex_1">vuex的组成<a class="headerlink" href="#vuex_1" title="Permanent link"></a></h4>
<ul>
<li>state：使用 state来存储应用中需要共享的状态。为了能让 Vue 组件在 state更改后也随着更改，需要基于state创建计算属性（mapGetters，mapState）</li>
<li>getters</li>
<li>mutations（同步）：改变store中的状态</li>
<li>actions（异步）：异步地更改状态，action并不直接改变state，而是发起mutation(也需要通过mutation才能更改state)</li>
<li>Module: 模块化store。由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store对象就有可能变得相当臃肿。Vuex 允许我们将 store分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块</li>
</ul>
<h4 id="_16">工作流程<a class="headerlink" href="#_16" title="Permanent link"></a></h4>
<ul>
<li>1、数据从state中渲染到页面</li>
<li>2、在页面通过dispatch来触发action</li>
<li>3、action通过调用commit,来触发mutation</li>
<li>4、mutation来更改数据，数据变更之后会触发dep对象的notify，通知所有Watcher对象去修改对应视图（vue的双向数据绑定原理）</li>
</ul>
<h4 id="_17">应用场景<a class="headerlink" href="#_17" title="Permanent link"></a></h4>
<ul>
<li>多个视图依赖于同一状态</li>
<li>来自不同视图的行为需要改变同一个状态</li>
</ul>
<h4 id="_18">参考链接<a class="headerlink" href="#_18" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5e7ae687f265da57424bb691#heading-21" target="_blank">https://juejin.im/post/5e7ae687f265da57424bb691#heading-21</a>  </p>
<h3 id="vuevue-router">vue路由（vue-router）<a class="headerlink" href="#vuevue-router" title="Permanent link"></a></h3>
<h4 id="_19">组件<a class="headerlink" href="#_19" title="Permanent link"></a></h4>
<ul>
<li><code>&lt;router-link&gt;</code></li>
<li><code>&lt;router-view&gt;</code>:用于渲染匹配的组件</li>
<li><code>&lt;keep-alive&gt;</code>:是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 。也就是所谓的-----组件缓存</li>
</ul>
<h4 id="_20">路由分类<a class="headerlink" href="#_20" title="Permanent link"></a></h4>
<ul>
<li>动态路由:使用 path 属性过程中，使用动态路径参数，以冒号开头,如：<br />
<div class="highlight"><pre><span class="p">{</span>
    <span class="nx">path</span><span class="o">:</span> <span class="sr">/user/</span><span class="o">:</span><span class="nx">id</span>     <span class="c1">//id为1，路径为 /user/1  </span>
    <span class="nx">component</span><span class="o">:</span> <span class="nx">User</span>  
<span class="p">}</span>
</pre></div></li>
<li>嵌套路由:<code>&lt;router-view&gt;</code>,需要在 VueRouter 的参数中使用 children 配置</li>
</ul>
<p>导航：</p>
<ul>
<li>声明式 <code>&lt;router-link :to="...</code></li>
<li>编程式 <code>router.push(...)</code></li>
</ul>
<h4 id="_21">路由对象<a class="headerlink" href="#_21" title="Permanent link"></a></h4>
<p>使用了vue-router的应用中,路由对象会被注入每个组件中，赋值为 this.$route<br />
属性：  </p>
<ul>
<li>$route.path </li>
<li>$route.params</li>
<li>$route.query </li>
<li>$route.router </li>
<li>$route.name </li>
<li>$route.matched:数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象,如/home/news/detail/:id这条路径，它包含3条匹配的路由：  <ul>
<li>/home/news/detail/:id</li>
<li>/home/news</li>
<li>/home</li>
</ul>
</li>
</ul>
<h4 id="_22">路由的钩子函数（导航守卫）<a class="headerlink" href="#_22" title="Permanent link"></a></h4>
<p>路由的切换过程，本质上是执行一系列路由钩子函数，钩子函数总体上分为两大类：  </p>
<ul>
<li>全局的钩子函数<ul>
<li>beforeEach：在路由切换开始时调用</li>
<li>afterEach：在每次路由切换成功进入激活阶段时被调用</li>
</ul>
</li>
<li>单个路由的钩子函数<ul>
<li>beforeEnter</li>
<li>beforeLeave</li>
</ul>
</li>
<li>组件的钩子函数<ul>
<li>beforeRouteEnter ：在渲染该组件的对应路由被 confirm 前调用</li>
<li>beforeRouteUpdate：在当前路由改变，但是该组件被复用时调用</li>
<li>beforeRouteLeave：导航离开该组件的对应路由时调用</li>
</ul>
</li>
</ul>
<h4 id="_23">重定向和别名<a class="headerlink" href="#_23" title="Permanent link"></a></h4>
<p>重定向：<code>routes: [{ path: '/a', redirect: '/b' }]</code><br />
别名：<code>routes: [{ path: '/a', component: A, alias: '/b' }]</code></p>
<h4 id="_24">常见问题<a class="headerlink" href="#_24" title="Permanent link"></a></h4>
<p>1、route和router的区别？  </p>
<ul>
<li>router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等</li>
<li>route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数  </li>
</ul>
<p>2、vue-router实现路由懒加载（动态加载路由）  </p>
<ul>
<li>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应的组件即为路由的懒加载，可以加快项目的加载速度，提高效率  </li>
</ul>
<p>3、active-class 是哪个组件的属性？  </p>
<ul>
<li>active-class是router-link终端属性，用来做选中样式的切换，当router-link标签被点击时将会应用这个样式  </li>
</ul>
<h4 id="_25">参考链接<a class="headerlink" href="#_25" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/axl234/p/5899952.html" target="_blank">https://www.cnblogs.com/axl234/p/5899952.html</a><br />
<a href="https://juejin.im/post/5e7ae687f265da57424bb691#heading-24" target="_blank">https://juejin.im/post/5e7ae687f265da57424bb691#heading-24</a></p>
<h2 id="202065">2020/6/5<a class="headerlink" href="#202065" title="Permanent link"></a></h2>
<h3 id="mixin">Mixin（混入）<a class="headerlink" href="#mixin" title="Permanent link"></a></h3>
<p>混入 (mixin) 提供了一种非常灵活的方式，来分发Vue组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项  </p>
<h4 id="_26">使用场景<a class="headerlink" href="#_26" title="Permanent link"></a></h4>
<p>有两个非常相似的组件，他们的基本功能是一样的，但他们之间又存在着足够的差异性，此时的你就像是来到了一个分岔路口：我是把它拆分成两个不同的组件呢？还是保留为一个组件，然后通过props传值来创造差异性从而进行区分呢？<br />
两种解决方案都不够完美：如果拆分成两个组件，你就不得不冒着一旦功能变动就要在两个文件中更新代码的风险，这违背了DRY原则（Don’t Repeat Yourself）。反之，太多的props传值会很快变得混乱不堪，从而迫使维护者在使用组件的时候必须理解一大段的上下文，拖慢写码速度。<br />
Mixin允许你封装一块在应用的其他组件中都可以使用的<strong>函数</strong>。如果使用姿势得当，他们不会改变函数作用域外部的任何东西，因此哪怕执行多次，只要是同样的输入你总是能得到一样的值<br />
即页面的风格不用，但是执行的方法和需要的数据类似可以使用mixin
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">mixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nx">conflicting</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;from mixin&#39;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">vm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="nx">mixins</span><span class="o">:</span> <span class="p">[</span><span class="nx">mixin</span><span class="p">],</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">bar</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nx">conflicting</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;from self&#39;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="nx">vm</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span> <span class="c1">// =&gt; &quot;foo&quot;</span>
<span class="nx">vm</span><span class="p">.</span><span class="nx">bar</span><span class="p">()</span> <span class="c1">// =&gt; &quot;bar&quot;</span>
<span class="nx">vm</span><span class="p">.</span><span class="nx">conflicting</span><span class="p">()</span> <span class="c1">// =&gt; &quot;from self&quot;</span>
</pre></div></p>
<h2 id="2020610">2020/6/10<a class="headerlink" href="#2020610" title="Permanent link"></a></h2>
<h3 id="vue_2">vue自定义指令（项目中实践用到的）<a class="headerlink" href="#vue_2" title="Permanent link"></a></h3>
<h4 id="_27">使用方式<a class="headerlink" href="#_27" title="Permanent link"></a></h4>
<ul>
<li>注册全局指令&ndash;用 <strong>directive</strong>
<div class="highlight"><pre><span class="c1">// 注册一个全局自定义指令 `v-focus`</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">directive</span><span class="p">(</span><span class="s1">&#39;focus&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">// 当被绑定的元素插入到 DOM 中时……</span>
  <span class="nx">inserted</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">el</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 聚焦元素</span>
    <span class="nx">el</span><span class="p">.</span><span class="nx">focus</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></div></li>
<li>注册局部指令&ndash;用 <strong>directives</strong>
<div class="highlight"><pre><span class="c1">// 注册一个注册局部指令 `v-focus`</span>
<span class="nx">data</span><span class="p">(){</span>
<span class="p">},</span>
<span class="nx">directives</span><span class="o">:</span> <span class="p">{</span>
  <span class="nx">focus</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// 指令的定义,钩子函数等</span>
    <span class="nx">inserted</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">el</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">el</span><span class="p">.</span><span class="nx">focus</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
或者
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">focus</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">//钩子函数等</span>
<span class="p">}</span>
</pre></div>
绑定使用
<code>&lt;input v-focus&gt;</code></li>
</ul>
<h4 id="_28">指令定义对象的钩子函数<a class="headerlink" href="#_28" title="Permanent link"></a></h4>
<ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中</li>
<li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。</li>
<li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li>unbind：只调用一次，指令与元素解绑时调用。</li>
</ul>
<h4 id="_29">钩子函数的参数<a class="headerlink" href="#_29" title="Permanent link"></a></h4>
<ul>
<li>el：指令所绑定的元素，可以用来直接操作 DOM。</li>
<li>binding：一个对象，包含以下 property：<ul>
<li>name：指令名，不包括 v- 前缀。</li>
<li>value：指令的绑定值，例如：v-my-directive=&rdquo;1 + 1&rdquo; 中，绑定值为 2。</li>
<li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>
<li>expression：字符串形式的指令表达式。例如 v-my-directive=&rdquo;1 + 1&rdquo; 中，表达式为 &ldquo;1 + 1&rdquo;。</li>
<li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &ldquo;foo&rdquo;。</li>
<li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li>
</ul>
</li>
<li>vnode：Vue 编译生成的虚拟节点。</li>
<li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。
除了 el之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行</li>
</ul>
<h4 id="_30">使用实例代码<a class="headerlink" href="#_30" title="Permanent link"></a></h4>
<ul>
<li>实例一 点击除div之外的地方隐藏div的实现（局部）
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="c">&lt;!-- 绑定具体关闭div方法 --&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">v-clickoutside</span><span class="o">=</span><span class="s">&quot;handleClose&quot;</span> <span class="na">v-show</span><span class="o">=</span><span class="s">&quot;show&quot;</span><span class="p">&gt;</span>
  显示
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="kr">const</span> <span class="nx">clickoutside</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 初始化指令</span>
    <span class="nx">bind</span><span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">binding</span><span class="p">,</span> <span class="nx">vnode</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">function</span> <span class="nx">documentHandler</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 这里判断点击的元素是否是本身，是本身，则返回</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 判断指令中是否绑定了函数</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">binding</span><span class="p">.</span><span class="nx">expression</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 如果绑定了函数 则调用那个函数，此处binding.value就是handleClose方法</span>
          <span class="nx">binding</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 给当前元素绑定个私有变量，方便在unbind中可以解除事件监听</span>
      <span class="nx">el</span><span class="p">.</span><span class="nx">__vueClickOutside__</span> <span class="o">=</span> <span class="nx">documentHandler</span><span class="p">;</span>
      <span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="nx">documentHandler</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">update</span><span class="p">()</span> <span class="p">{},</span>
    <span class="nx">unbind</span><span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">binding</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 解除事件监听</span>
      <span class="nb">document</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="nx">el</span><span class="p">.</span><span class="nx">__vueClickOutside__</span><span class="p">);</span>
      <span class="k">delete</span> <span class="nx">el</span><span class="p">.</span><span class="nx">__vueClickOutside__</span><span class="p">;</span>
    <span class="p">},</span>
  <span class="p">};</span>
  <span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;HelloWorld&#39;</span><span class="p">,</span>
    <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">show</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="p">};</span>
    <span class="p">},</span>
    <span class="nx">directives</span><span class="o">:</span> <span class="p">{</span><span class="nx">clickoutside</span><span class="p">},</span>
    <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">handleClose</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">show</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">},</span>
    <span class="p">},</span>
<span class="p">};</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div></li>
<li>实例二 防重复点击(全局)
<div class="highlight"><pre><span class="nx">Vue</span><span class="p">.</span><span class="nx">directive</span><span class="p">(</span><span class="s1">&#39;noMoreClick&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">inserted</span> <span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">binding</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="nx">e</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">//el.classList.add(&#39;is-loading&#39;)  //添加类名</span>
      <span class="nx">el</span><span class="p">.</span><span class="nx">disabled</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">el</span><span class="p">.</span><span class="nx">disabled</span> <span class="o">=</span> <span class="kc">false</span>
      <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></div></li>
</ul>
<h4 id="_31">参考链接<a class="headerlink" href="#_31" title="Permanent link"></a></h4>
<p><a href="https://blog.csdn.net/weixin_33877092/article/details/91368472" target="_blank">https://blog.csdn.net/weixin_33877092/article/details/91368472</a><br />
<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank">https://cn.vuejs.org/v2/guide/custom-directive.html</a></p>
<h2 id="2020611">2020/6/11<a class="headerlink" href="#2020611" title="Permanent link"></a></h2>
<h3 id="_32">原型、原型链<a class="headerlink" href="#_32" title="Permanent link"></a></h3>
<p>JavaScript没有&rdquo;子类&rdquo;和&rdquo;父类&rdquo;的概念，也没有&rdquo;类&rdquo;（class）和&rdquo;实例&rdquo;（instance）的区分，全靠一种很奇特的&rdquo;原型链&rdquo;（prototype chain）模式，来实现继承<br />
<strong>在Javascript语言中，new命令后面跟的不是类，而是构造函数</strong>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">DOG</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">dogA</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DOG</span><span class="p">(</span><span class="s1">&#39;大毛&#39;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">dogA</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 大毛</span>
</pre></div>
DOG的构造函数，表示狗对象的原型,对这个构造函数使用new，就会生成一个狗对象的实例</p>
<h4 id="new">new运算符的缺点<a class="headerlink" href="#new" title="Permanent link"></a></h4>
<p><strong>用构造函数生成实例对象，无法共享属性和方法</strong><br />
每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费</p>
<h4 id="prototype">protoType属性<a class="headerlink" href="#prototype" title="Permanent link"></a></h4>
<p>（构造函数的）protoType属性包含一个对象（以下简称&rdquo;prototype对象&rdquo;），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面<br />
实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的<br />
由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像&rdquo;继承&rdquo;了prototype对象一样</p>
<h4 id="_33">原型链<a class="headerlink" href="#_33" title="Permanent link"></a></h4>
<p>js里完全依靠&rdquo;原型链&rdquo;(prototype chain)模式来实现继承</p>
<ul>
<li>__proto__：事实上就是原型链指针，指向了 <strong>实例对象的原型</strong>，它也是一个对象</li>
<li>prototype：上面说到这个是 <strong>指向原型对象</strong> 的</li>
<li>constructor：每一个原型对象都包含一个指向 <strong>构造函数</strong> 的指针，就是constructor</li>
</ul>
<p>构造函数的 prototype 指向调用该构造函数而创建的实例对象的原型<br />
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">Cat</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">cat</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Cat</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>   <span class="c1">// true</span>
</pre></div>
构造函数和构造函数的 prototype 可以相互指向<br />
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">Cat</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Cat</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Cat</span><span class="p">)</span>    <span class="c1">// true</span>
</pre></div>
Object.prototype 的原型是null  (Object.prototype 没有原型)<br />
<code>console.log(Object.prototype.__proto__ === null) // true</code></p>
<h4 id="_34">继承<a class="headerlink" href="#_34" title="Permanent link"></a></h4>
<p>实例.__proto__ === 原型<br />
原型.constructor === 构造函数<br />
构造函数.prototype === 原型</p>
<h4 id="_35">参考链接<a class="headerlink" href="#_35" title="Permanent link"></a></h4>
<p><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank">http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html</a><br />
<a href="https://www.yuque.com/fe9/basic/zk5e4f" target="_blank">https://www.yuque.com/fe9/basic/zk5e4f</a></p>
<h2 id="2020618">2020/6/18<a class="headerlink" href="#2020618" title="Permanent link"></a></h2>
<h3 id="vue-filter">vue 自定义过滤器（filter）<a class="headerlink" href="#vue-filter" title="Permanent link"></a></h3>
<p><strong>注：可联系上文的（自定义指令）</strong><br />
过滤器可以用在两个地方：<strong>双花括号插值</strong>和 <strong>v-bind表达式</strong> <br />
<div class="highlight"><pre><span class="c">&lt;!-- 在双花括号中 --&gt;</span>
{{ message | capitalize }}

<span class="c">&lt;!-- 在 `v-bind` 中 --&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">v-bind:id</span><span class="o">=</span><span class="s">&quot;rawId | formatId&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div>
capitalize 过滤器函数将会收到 message 的值作为第一个参数<br />
前者为过滤器参数，后者为过滤器函数</p>
<h4 id="_36">组件过滤器和全局过滤器<a class="headerlink" href="#_36" title="Permanent link"></a></h4>
<p>当全局过滤器和局部过滤器重名时，会采用局部过滤器</p>
<ul>
<li>组件过滤器————<strong>filters</strong>
<div class="highlight"><pre><span class="nx">filters</span><span class="o">:</span> <span class="p">{</span>
  <span class="nx">capitalize</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">value</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;&#39;</span>
    <span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="o">+</span> <span class="nx">value</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></li>
<li>全局过滤器————<strong>filter</strong>
<div class="highlight"><pre>Vue.filter(&#39;capitalize&#39;, function (value) {
  if (!value) return &#39;&#39;
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})
new Vue({
  //...
})
</pre></div></li>
</ul>
<h4 id="_37">参考链接<a class="headerlink" href="#_37" title="Permanent link"></a></h4>
<p><a href="https://cn.vuejs.org/v2/guide/filters.html" target="_blank">https://cn.vuejs.org/v2/guide/filters.html</a><br />
<a href="https://www.jianshu.com/p/ad21df1914c5" target="_blank">https://www.jianshu.com/p/ad21df1914c5</a>  </p>
<h2 id="2020622">2020/6/22<a class="headerlink" href="#2020622" title="Permanent link"></a></h2>
<h3 id="css-dispalypositionfloat">CSS布局&ndash;dispaly、position、float<a class="headerlink" href="#css-dispalypositionfloat" title="Permanent link"></a></h3>
<p>p, ul, form, div等元素被称为块级元素，这些元素显示为一块儿内容（会自动换行），span, input 等元素称为行内元素  </p>
<ul>
<li>块级元素会从上到下一个个垂直排列，每个自占一行  </li>
<li>行内元素在一行中水平排列，行内元素的高度由其内容撑开，不可显示的设置其高度</li>
</ul>
<h4 id="-position">定位&ndash;position<a class="headerlink" href="#-position" title="Permanent link"></a></h4>
<ul>
<li>inhert：规定应该从父元素继承 position 属性的值。</li>
<li>static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li>
<li>relative：生成相对定位的元素，相对于元素本身正常位置进行定位。因此，&rdquo;left:20&rdquo; 会向元素的 LEFT 位置添加 20 像素。</li>
<li>absolute：生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。元素的位置通过 &ldquo;left&rdquo;, &ldquo;top&rdquo;, &ldquo;right&rdquo; 以及 &ldquo;bottom&rdquo; 属性进行规定。</li>
<li>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 &ldquo;left&rdquo;, &ldquo;top&rdquo;, &ldquo;right&rdquo; 以及 &ldquo;bottom&rdquo; 属性进行规定。</li>
</ul>
<p>CSS有三种基本的定位机制：<strong>普通流、浮动和绝对定位</strong><br />
绝对定位的元素的位置是相对于距离他最近的非static祖先元素位置决定的  </p>
<h4 id="_38">浮动<a class="headerlink" href="#_38" title="Permanent link"></a></h4>
<p>clear:both可以清除浮动<br />
应用值为hidden或auto的overflow属性会有一个副作用：自动清理包含的任何浮动元素</p>
<h4 id="_39">参考链接<a class="headerlink" href="#_39" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/dolphinX/archive/2012/10/13/2722501.html" target="_blank">https://www.cnblogs.com/dolphinX/archive/2012/10/13/2722501.html</a><br />
<a href="https://blog.csdn.net/liulanzaijia/article/details/87725232" target="_blank">https://blog.csdn.net/liulanzaijia/article/details/87725232</a></p>
<h2 id="2020623">2020/6/23<a class="headerlink" href="#2020623" title="Permanent link"></a></h2>
<h3 id="inline-blockfloat">inline-block和float<a class="headerlink" href="#inline-blockfloat" title="Permanent link"></a></h3>
<ul>
<li><strong>inline-block</strong>： inline-block的元素就是宽高可设置，相邻的元素会在一行显示，直到本行排满，也就是让元素的容器属性为block，内容为inline.不会脱离文档流</li>
<li><strong>float</strong>： 设置元素的浮动为左或者右浮动，当设置元素浮动时，相邻元素会根据自身大小，排满一行，如果父容器宽度不够则会换行。当我们设置了元素的浮动时，这个元素就脱离了文档流，相邻元素会呈环绕装排列</li>
</ul>
<h4 id="_40">区别<a class="headerlink" href="#_40" title="Permanent link"></a></h4>
<ul>
<li>inline-block: 水平排列一行，即使元素高度不一，也会以高度最大的元素高度为行高，即使高度小的元素周围留空，也不回有第二行元素上浮补位。可以设置默认的垂直对齐基线</li>
<li>float：让元素脱离当前文档流，呈环绕装排列，如遇上行有空白，而当前元素大小可以挤进去，这个元素会在上行补位排列。默认是顶部对齐</li>
</ul>
<p>当我们要设置某些元素在一行显示，并且排列方向一致的情况下，我们尽可能去用inline-block。因为inline-block的元素仍然在当前文档流里面，这样就减少了程序对DOM的更改操作，因为DOM的每一次更改，浏览器会重绘DOM树。理论上会增加性能消耗。这样也不用像flaot那样麻烦，需要清除flaot  </p>
<h4 id="_41">参考链接<a class="headerlink" href="#_41" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/scot/p/5501669.html" target="_blank">https://www.cnblogs.com/scot/p/5501669.html</a></p>
<h3 id="cookiesessiontoken">cookie、session、token（令牌）<a class="headerlink" href="#cookiesessiontoken" title="Permanent link"></a></h3>
<h4 id="cookie">cookie<a class="headerlink" href="#cookie" title="Permanent link"></a></h4>
<ul>
<li><strong>HTTP 是无状态的协议</strong>（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li>
<li><strong>cookie 存储在客户端</strong>： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li>
<li><strong>cookie 是不可跨域的</strong>： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）</li>
</ul>
<p><strong>cookie属性</strong>  </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>name=value</td>
<td>键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型</td>
</tr>
<tr>
<td>domain</td>
<td>指定 cookie 所属域名，默认是当前域名</td>
</tr>
<tr>
<td>path</td>
<td>指定 cookie 在哪个路径（路由）下生效，默认是 &lsquo;/&rsquo;。</td>
</tr>
<tr>
<td>maxAge</td>
<td>cookie 失效的时间，单位秒。 比 expires 好用</td>
</tr>
<tr>
<td>expires</td>
<td>过期时间，在设置的某个时间点后该 cookie 就会失效</td>
</tr>
<tr>
<td>secure</td>
<td>该 cookie 是否仅被使用安全协议传输。当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效</td>
</tr>
<tr>
<td>httpOnly</td>
<td>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</td>
</tr>
</tbody>
</table>
<h4 id="session">session<a class="headerlink" href="#session" title="Permanent link"></a></h4>
<ul>
<li>session 是另一种记录服务器和客户端会话状态的机制  </li>
<li>session 是基于 cookie 实现的，session 存储在服务器端，<strong>sessionId</strong> 会被存储到客户端的cookie 中  </li>
<li>session 认证流程<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li>
<li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作</li>
</ul>
</li>
</ul>
<p><strong>SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态</strong></p>
<h4 id="cookiesession">cookie与session的区别<a class="headerlink" href="#cookiesession" title="Permanent link"></a></h4>
<ul>
<li>安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li>
<li>存取值的类型不同：Cookie只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li>
<li>有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li>
<li>存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源</li>
</ul>
<p>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</p>
<h4 id="token">token<a class="headerlink" href="#token" title="Permanent link"></a></h4>
<p>token 也称作令牌，由uid+time+sign[+固定参数]<br />
token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据<br />
<strong>存放</strong>：token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中  </p>
<ul>
<li>Acesss Token<ul>
<li>访问资源接口（API）时所需要的资源凭证</li>
<li>简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li>
<li><strong>特点</strong>：<ul>
<li>服务端无状态化、可扩展性好</li>
<li>支持移动端设备</li>
<li>安全</li>
<li><strong>支持跨程序调用</strong></li>
</ul>
</li>
<li>token 的身份验证流程  <ol>
<li>客户端使用用户名跟密码请求登录  </li>
<li>服务端收到请求，去验证用户名与密码  </li>
<li>验证成功后，服务端会签发一个token并把这个token发送给客户端  </li>
<li>客户端收到token以后，会把它存储起来，比如放在cookie里或者localStorage里  </li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的token服务端收到请求，然后去验证客户端请求里面带着的token，如果验证成功，就向客户端返回请求的数据</li>
</ol>
</li>
<li>每一次请求都需要携带 token，需要把 token 放到HTTP的Header里</li>
<li>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放token数据。用解析token的计算时间换取session的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</li>
<li>token 完全由应用管理，所以它可以避开同源策略</li>
</ul>
</li>
<li>refresh token  <ul>
<li>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作</li>
<li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了</li>
<li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向Session一样一直保持在内存中以应对大量的请求</li>
</ul>
</li>
</ul>
<p><strong>token可以抵抗CSRF（跨站请求伪造）攻击，cookie+session不行，因为请求中发送的是token而不是cookie，cookie只用来存储token而不用于认证</strong></p>
<h4 id="sessiontoken">分布式情况下的session和token<a class="headerlink" href="#sessiontoken" title="Permanent link"></a></h4>
<p>session是有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题  </p>
<ul>
<li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。</li>
</ul>
<p>而token是无状态的，token字符串里就保存了所有的用户信息  </p>
<ul>
<li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)</li>
</ul>
<h4 id="jwtjson-web-token">JWT（Json Web Token）<a class="headerlink" href="#jwtjson-web-token" title="Permanent link"></a></h4>
<ul>
<li>JSON Web Token（简称 JWT）是目前最流行的 <strong>跨域认证解决方案</strong>。</li>
<li>是一种认证授权机制。JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。</li>
<li>JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li>
<li>可以使用HMAC算法或者是RSA的公/私秘钥对JWT进行签名。因为数字签名的存在，这些传递的信息是可信的。</li>
<li>具体可参考 <a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a><br />
<strong>JWT组成</strong></li>
<li>Header（头部）：一个JSON对象，描述JWT的元数据，（使用 Base64URL算法将JSON对象转成字符串）</li>
<li>Payload（负载）：一个JSON对象，用来存放实际需要传递的数据，<strong>JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分</strong>（这个 JSON 对象也要使用 Base64URL 算法转成字符串）</li>
<li>Signature（签名）：是对前两部分的签名，防止数据篡改</li>
</ul>
<p>用<code>.</code>分隔，即Header.Payload.Signature<br />
<strong>JWT使用方式</strong><br />
客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。此后，客户端每次与服务器通信，都要带上这个 JWT。</p>
<ul>
<li>可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面<code>Authorization: Bearer &lt;token&gt;</code></li>
<li>跨域的时候，JWT就放在POST请求的数据体里面</li>
<li>通过 URL 传输 如<code>http://www.example.com/user?token=xxx</code></li>
</ul>
<p><strong>token与JWT的区别</strong><br />
服务端验证客户端发来的token信息要进行数据的查询操作(服务端查询数据库存储的token信息)；JWT验证客户端发来的token信息就不用，在服务端使用密钥校验就可以，不用数据库的查询。</p>
<h4 id="_42">总结<a class="headerlink" href="#_42" title="Permanent link"></a></h4>
<ul>
<li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li>
<li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li>
<li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li>
<li>jwt只是一个跨域认证的方案</li>
</ul>
<h4 id="_43">参考链接<a class="headerlink" href="#_43" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5e055d9ef265da33997a42cc" target="_blank">https://juejin.im/post/5e055d9ef265da33997a42cc</a><br />
<a href="https://segmentfault.com/a/1190000017831088" target="_blank">https://segmentfault.com/a/1190000017831088</a><br />
<a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank">https://www.cnblogs.com/moyand/p/9047978.html</a></p>
<h2 id="2020628">2020/6/28<a class="headerlink" href="#2020628" title="Permanent link"></a></h2>
<h3 id="_44">前端跨域<a class="headerlink" href="#_44" title="Permanent link"></a></h3>
<h4 id="_45">浏览器同源策略<a class="headerlink" href="#_45" title="Permanent link"></a></h4>
<p><strong>所谓同源是指：域名、协议、端口相同</strong>  </p>
<ul>
<li>DOM同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的iframe是限制互相访问的。（如果没有限制，用户可以操作内嵌iframe的DOM节点，可以获取用户账号密码等信息）</li>
<li>XMLHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求（如果没有限制，可以进行CSRF（跨站请求伪造）攻击：在访问正常页面时点击了恶意页面，通过执行页面中的恶意AJAX请求代码，此时请求附带了合法的cookie，后台会验证正确返回正确response，造成数据泄露）</li>
</ul>
<h4 id="_46">同域、父域子域<a class="headerlink" href="#_46" title="Permanent link"></a></h4>
<p>同域规则只有1个，即必须满足三个相同：相同协议，相同域名，相同端口。上述3个点有一个不相同，便是跨域。a.google.com和a.b.google.com理解为是相同一级域名google.com的子域，可以称它们两个为同父域，同一个父域(父级域名)不能混淆为同域，这是两个概念<br />
<strong>关于跨域</strong>  </p>
<ul>
<li>如果是协议和端口造成的跨域问题，前端无法解决；</li>
<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。所以 <strong>域名和域名对应ip</strong>  <code>http://www.a.com/a.js
http://70.32.92.74/b.js</code> 是跨域的</li>
</ul>
<h4 id="_47">跨域解决办法<a class="headerlink" href="#_47" title="Permanent link"></a></h4>
<h5 id="cors">CORS（跨域资源共享）<a class="headerlink" href="#cors" title="Permanent link"></a></h5>
<p>CORS（Cross-origin resource sharing，跨域资源共享）是一个W3C标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败<br />
CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10<br />
整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求<br />
<strong>实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信</strong><br />
CORS请求分类：<strong>简单请求</strong>和 <strong>非简单请求</strong>  </p>
<div class="highlight"><pre>1、请求方法是以下三种方法之一：HEAD、POST、GET  
2、HTTP头部信息不超出以下几种字段：Accept、Accept-Language、Content-Language、Last-Event-ID、
Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 
</pre></div>

<p>同时满足上述两个条件即为简单请求，否则为非简单请求。浏览器对这两种请求的处理是不一样的</p>
<ul>
<li>
<p>简单请求</p>
<ul>
<li>在请求中需要附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：<code>Origin:http://www.laixiangran.cn</code></li>
<li>如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发 * ）。例如：<code>Access-Control-Allow-Origin：http://www.laixiangran.cn</code></li>
<li>没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。<strong>注意，请求和响应都不包含 cookie 信息</strong></li>
<li><strong>如果需要包含cookie信息</strong>,ajax请求需要设置xhr的属性withCredentials为true，服务器需要设置响应头部 <code>Access-Control-Allow-Credentials: true</code>，且Access-Control-Allow-Origin不能设为星号，必须指定明确的、与请求网页一致的域名</li>
</ul>
</li>
<li>
<p>非简单请求<br />
非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。<br />
浏览器在发送真正的请求之前，会先发送一个Preflight请求（预检请求）给服务器，这种请求使用 OPTIONS 方法，发送下列头部：  </p>
<ul>
<li>Origin：与简单的请求相同。 </li>
<li>Access-Control-Request-Method: 请求自身使用的方法。  </li>
<li>Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。</li>
</ul>
</li>
</ul>
<p>如：<br />
<div class="highlight"><pre><span class="nx">Origin</span><span class="o">:</span> <span class="nx">http</span><span class="o">:</span><span class="c1">//www.laixiangran.cn</span>
<span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Request</span><span class="o">-</span><span class="nx">Method</span><span class="o">:</span> <span class="nx">POST</span>
<span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Request</span><span class="o">-</span><span class="nx">Headers</span><span class="o">:</span> <span class="nx">NCZ</span>
</pre></div>
发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：  </p>
<ul>
<li>Access-Control-Allow-Origin：与简单的请求相同。  </li>
<li>Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。  </li>
<li>Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。  </li>
<li>Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。  </li>
</ul>
<p>例如：
<div class="highlight"><pre><span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Allow</span><span class="o">-</span><span class="nx">Origin</span><span class="o">:</span> <span class="nx">http</span><span class="o">:</span><span class="c1">//www.laixiangran.cn</span>
<span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Allow</span><span class="o">-</span><span class="nx">Methods</span><span class="o">:</span> <span class="nx">GET</span><span class="p">,</span> <span class="nx">POST</span>
<span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Allow</span><span class="o">-</span><span class="nx">Headers</span><span class="o">:</span> <span class="nx">NCZ</span>
<span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Max</span><span class="o">-</span><span class="nx">Age</span><span class="o">:</span> <span class="mi">1728000</span>
</pre></div></p>
<p>一旦服务器通过Preflight请求允许该请求之后，以后每次浏览器正常的CORS请求，就都跟简单请求一样了。</p>
<p><strong>CORS跨域优点与缺点</strong>  </p>
<ul>
<li>优点<ul>
<li>CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。</li>
<li>支持所有类型的 HTTP 请求</li>
</ul>
</li>
<li>缺点<ul>
<li>存在兼容性问题，特别是 IE10 以下的浏览器。</li>
<li>第一次发送非简单请求时会多一次请求。</li>
</ul>
</li>
</ul>
<h5 id="jsonp">JSONP 跨域<a class="headerlink" href="#jsonp" title="Permanent link"></a></h5>
<p>由于 <strong>script标签不受浏览器同源策略的影响</strong>，允许跨域引用资源。因此可以通过动态创建 script标签，然后利用src属性进行跨域，这也就是JSONP跨域的基本原理<br />
(<strong>注：form表单提交没有跨域问题</strong> :因为原页面用form提交到另一个域名之后，原页面的脚本无法获取新页面中的内容。所以浏览器认为这是安全的)<br />
<strong>JSONP跨域流程</strong><br />
例1：
<div class="highlight"><pre><span class="c1">// 1. 定义一个 回调函数 handleResponse 用来接收返回的数据</span>
<span class="kd">function</span> <span class="nx">handleResponse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse</span>
<span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">gerElement</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">);</span>
<span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="s1">&#39;http://www.laixiangran.cn/json?callback=handleResponse&#39;</span><span class="p">;</span>
<span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>

<span class="c1">// 3. 通过 script.src 请求 `http://www.laixiangran.cn/json?callback=handleResponse`，</span>
<span class="c1">// 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse({&quot;name&quot;: &quot;laixiangran&quot;}) 给浏览器</span>
<span class="c1">// 5. 浏览器在接收到 handleResponse({&quot;name&quot;: &quot;laixiangran&quot;}) 之后立即执行 ，也就是执行 handleResponse 方法，</span>
<span class="c1">//获得后端返回的数据，这样就完成一次跨域请求了。</span>
</pre></div>
例2：
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span><span class="p">&gt;</span>
    <span class="kd">function</span> <span class="nx">dosomething</span><span class="p">(</span><span class="nx">jsondata</span><span class="p">){</span>
        <span class="c1">//处理获得的json数据</span>
    <span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;http://example.com/data.php?callback=dosomething&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div>
<em>注：回调函数名前后端需一致</em><br />
<strong>JSONP跨域优点与缺点</strong>  </p>
<ul>
<li>优点<ul>
<li>使用简便，没有兼容性问题，目前最流行的一种跨域方法</li>
</ul>
</li>
<li>缺点<ul>
<li>只支持 GET 请求。</li>
<li>由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。</li>
<li>要确定JSONP请求是否失败并不容易。虽然 HTML5给script标签新增了一个onerror事件处理程序，但是存在兼容性问题</li>
</ul>
</li>
</ul>
<p><strong>JSONP与CORS比较</strong>  </p>
<ul>
<li>JSONP只支持GET请求，CORS支持所有类型的HTTP请求</li>
<li>JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</li>
</ul>
<h5 id="ping">图像 Ping 跨域<a class="headerlink" href="#ping" title="Permanent link"></a></h5>
<p>由于 img 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理<br />
实例：
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">img</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>

<span class="c1">// 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">img</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Done!&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 请求数据通过查询字符串形式发送</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="s1">&#39;http://www.laixiangran.cn/test?name=laixiangran&#39;</span><span class="p">;</span>
</pre></div></p>
<ul>
<li>优点<ul>
<li>用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势</li>
</ul>
</li>
<li>缺点<ul>
<li>只支持 GET 请求。</li>
<li>只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。</li>
</ul>
</li>
</ul>
<h5 id="_48">服务器代理<a class="headerlink" href="#_48" title="Permanent link"></a></h5>
<p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。服务器代理是万能的</p>
<h5 id="documentdomain">document.domain 跨域<a class="headerlink" href="#documentdomain" title="Permanent link"></a></h5>
<p>对于主域名相同，而子域名不同的情况，可以使用document.domain来跨域。这种方式非常适用于 iframe跨域的情况.<br />
如：<code>http://www.laixiangran.cn/a.html 和 http://laixiangran.cn/b.html document.domain都设成laixiangran.cn即可通过js访问到iframe页面的各种属性和对象</code><br />
document.domain的设置是有限制的，只能把document.domain设置成自身或更高一级的父域，且主域必须相同</p>
<h5 id="documentname">document.name 跨域<a class="headerlink" href="#documentname" title="Permanent link"></a></h5>
<p>window对象有个name属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个window.name的，每个页面对 window.name 都有读写的权限。window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<br />
获取：<code>var data = iframe.contentWindow.name; // 获取 iframe 里的 window.name</code><br />
赋值：<code>window.name = "hello world!";</code></p>
<h5 id="locationhash">location.hash 跨域<a class="headerlink" href="#locationhash" title="Permanent link"></a></h5>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信<br />
location.hash 方式跨域，是子框架修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的（iframe跨域）。<br />
获取：<code>var data = window.location.hash;</code><br />
赋值：<code>parent.location.hash = "world";</code></p>
<h5 id="postmessage">postMessage 跨域<a class="headerlink" href="#postmessage" title="Permanent link"></a></h5>
<p>window.postMessage(message，targetOrigin) 方法是 HTML5 新引进的特性(API)，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。<br />
<code>otherWindow.postMessage(message, targetOrigin);</code></p>
<ul>
<li>otherWindow：目标窗口（你想发送跨域消息的那个窗口），例如： iframe.contentWindow 。是 window.frames 属性的成员或者由 window.open 方法创建的窗口</li>
<li>message: 要发送的消息，类型只能为String、Object (IE8、9 不支持)。</li>
<li>targetOrigin: 用来限定接收消息的那个 window 对象所在的域，不限定域使用通配符 *</li>
</ul>
<p>用法：<br />
a页面
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">iframe</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;http://laixiangran.cn/b.html&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;myIframe&quot;</span> <span class="na">onload</span><span class="o">=</span><span class="s">&quot;test()&quot;</span> <span class="na">style</span><span class="o">=</span><span class="s">&quot;display: none;&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// 1. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span>
    <span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 2. 获取 http://laixiangran.cn/b.html 页面的 window 对象，</span>
        <span class="c1">// 然后通过 postMessage 向 http://laixiangran.cn/b.html 页面发送消息</span>
        <span class="kd">var</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;myIframe&#39;</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">win</span> <span class="o">=</span> <span class="nx">iframe</span><span class="p">.</span><span class="nx">contentWindow</span><span class="p">;</span>
        <span class="nx">win</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;我是来自 http://www.laixiangran.cn/a.html 页面的消息&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div>
b页面
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span><span class="p">&gt;</span>
    <span class="c1">// 注册 message 事件用来接收消息</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">e</span> <span class="o">=</span> <span class="nx">e</span> <span class="o">||</span> <span class="nx">event</span><span class="p">;</span> <span class="c1">// 获取事件对象</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="c1">// 通过 data 属性得到发送来的消息</span>
    <span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div></p>
<p>子页面向父页面传递消息：
<code>window.parent.postMessage('子页面发送的消息','http://a.index.com')</code><br />
父页面监听同上  </p>
<p><strong>注意点</strong>  </p>
<ul>
<li>需要等到iframe中的子页面加载完成后才发送消息，否则子页面接收不到消息</li>
<li>在监听message事件时需要判断一下消息来源origin，避免接收到非法域名的消息导致的xss攻击（2020/7/27 复习存疑，这里应该是CSRF攻击吧）</li>
</ul>
<h4 id="_49">参考链接<a class="headerlink" href="#_49" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5ba1d4fe6fb9a05ce873d4ad" target="_blank">https://juejin.im/post/5ba1d4fe6fb9a05ce873d4ad</a><br />
CORS跨域（阮一峰）： <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank">http://www.ruanyifeng.com/blog/2016/04/cors.html</a><br />
<a href="https://juejin.im/post/5815f4abbf22ec006893b431" target="_blank">https://juejin.im/post/5815f4abbf22ec006893b431</a><br />
postMessage跨域：<a href="https://juejin.im/post/5e9045316fb9a03c957ff7ff" target="_blank">https://juejin.im/post/5e9045316fb9a03c957ff7ff</a></p>
<h2 id="2020629">2020/6/29<a class="headerlink" href="#2020629" title="Permanent link"></a></h2>
<h3 id="http">HTTP缓存机制<a class="headerlink" href="#http" title="Permanent link"></a></h3>
<p>报文中包含首部header和主体部分body。与缓存相关的规则信息就包含在header中<br />
HTTP的缓存属于客户端缓存。我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。<br />
缓存分为 <strong>强制缓存</strong> 和 <strong>协商缓存</strong><br />
两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商  </p>
<h4 id="_50">强制缓存<a class="headerlink" href="#_50" title="Permanent link"></a></h4>
<p><img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/huancun1.png" /><br />
当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据<br />
Expires和Cache-Control  </p>
<ul>
<li>Exprires: 值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。现在大多数使用Cache-Control替代</li>
<li>Cache-Control: 属性值<ul>
<li>private：客户端可以缓存</li>
<li>public：客户端和代理服务器都可以缓存</li>
<li>max-age=t：缓存内容将在t秒后失效</li>
<li>no-cache：需要使用协商缓存来验证缓存数据 </li>
<li>no-store：所有内容都不会缓存</li>
</ul>
</li>
</ul>
<h4 id="_51">协商缓存(对比缓存)<a class="headerlink" href="#_51" title="Permanent link"></a></h4>
<p><img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/huancun2.png" /><br />
客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据,更新后的缓存数据将存入缓存数据库<br />
  两种方案：Last-Modified和Etag  </p>
<ul>
<li>Last-Modified<ul>
<li>Last-Modified:服务器在响应请求时，会告诉浏览器资源的最后修改时间</li>
<li>if-Modified-Since:浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可<ul>
<li>被修改：传输响应一个整体，服务器返回：200 OK</li>
<li>没有被修改：只传输响应header，服务器返回：304 Not Modified</li>
</ul>
</li>
<li>if-Unmodified-Since:从某个时间点算起, 是否文件没有被修改<ul>
<li>没有被修改:则开始`继续&rsquo;传送文件: 服务器返回: 200 OK</li>
<li>被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag</p>
<ul>
<li>Etag<ul>
<li>Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</li>
<li>If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比<ul>
<li>不同，说明资源被改动过，则响应整个资源内容，返回状态码200</li>
<li>相同，说明资源无修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了</p>
<h4 id="_52">缓存的优点<a class="headerlink" href="#_52" title="Permanent link"></a></h4>
<ul>
<li>减少了冗余的数据传递，节省宽带流量</li>
<li>减少了服务器的负担，大大提高了网站性能</li>
<li>加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因</li>
</ul>
<h4 id="_53">不同刷新键执行缓存<a class="headerlink" href="#_53" title="Permanent link"></a></h4>
<ol>
<li>浏览器地址栏中写入URL，回车：浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）  </li>
<li>F5：F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since。  </li>
<li>Ctrl+F5：告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作</li>
</ol>
<h4 id="_54">参考链接<a class="headerlink" href="#_54" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5a1d4e546fb9a0450f21af23" target="_blank">https://juejin.im/post/5a1d4e546fb9a0450f21af23</a></p>
<h2 id="2020630">2020/6/30<a class="headerlink" href="#2020630" title="Permanent link"></a></h2>
<h3 id="_55">函数防抖与节流<a class="headerlink" href="#_55" title="Permanent link"></a></h3>
<h4 id="debounce">防抖（debounce）<a class="headerlink" href="#debounce" title="Permanent link"></a></h4>
<p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。<br />
应用场景：当执行用户输入搜索时。设置只有只用当用户停止输入1s后才自动执行搜索事件。否则不执行，在1s内如果用户重新输入，则清空计时，重新等到用户输入停止1s后执行搜索事件。
<div class="highlight"><pre><span class="c1">//代码为监听滚动事件</span>
<span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">wait</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">timeout</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span><span class="c1">//涉及闭包知识，见节流定时器版代码处说明</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">timeout</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> 
                <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timeout</span><span class="p">);</span>
        <span class="nx">timeout</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">wait</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 处理函数</span>
<span class="kd">function</span> <span class="nx">handle</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">());</span> 
<span class="p">}</span>
<span class="c1">// 滚动事件</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;scroll&#39;</span><span class="p">,</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">handle</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>
</pre></div></p>
<h4 id="throttle">节流（throttle）<a class="headerlink" href="#throttle" title="Permanent link"></a></h4>
<p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。<br />
对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。<br />
<div class="highlight"><pre><span class="c1">//时间戳版</span>
<span class="kd">var</span> <span class="nx">throttle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">prev</span> <span class="o">&gt;=</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
            <span class="nx">prev</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">handle</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">());</span>
<span class="p">}</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;scroll&#39;</span><span class="p">,</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">handle</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>
</pre></div></p>
<div class="highlight"><pre><span class="c1">//定时器版</span>
<span class="kd">var</span> <span class="nx">throttle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span><span class="c1">//涉及闭包知识</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">timer</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
                <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
            <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">handle</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">());</span>
<span class="p">}</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;scroll&#39;</span><span class="p">,</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">handle</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>
</pre></div>

<blockquote>
<p>注：防抖和节流可结合异步队列。有人有时候会疑惑为什么要把timer定在那个位置，原因要说清楚，因为闭包，可以让所有每一次触发的事件处理函数跟上一次的事件处理函数做到一个类似于人类交流之间的通信，因为有了这个共享的工具，这一次的事件处理函数就可以根据这个共享的工具去知道它的上一次是不是已经有处理逻辑被放到异步队列里头等待执行了。这就是timer的通俗解释，而为什么里头要判断一次timer是否为空，那是因为，这一次的事件处理函数如果不判断它的上一次有没有已经被放到异步队列当中了的话，直接执行下面的延时操作，结果是又有一个同样的处理逻辑被放入异步队列当中，因此触发的时候就要去根据timer判断任务队列中它有没有任务已经在里头等待了，有我们就clear它，让它滚蛋，因为我们要的结果是最后只能执行一次处理逻辑。 </p>
</blockquote>
<div class="highlight"><pre><span class="c1">//为帮助理解，可执行下列代码，闭包概念见下文  闭包  相关</span>
<span class="kd">function</span> <span class="nx">fn2</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;1:&quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">fn3</span><span class="p">(){</span>
        <span class="nx">a</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;2:&quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">fn1</span> <span class="o">=</span> <span class="nx">fn2</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span><span class="p">){</span>
    <span class="nx">fn1</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;3:&quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">)</span> <span class="c1">//a is not defined</span>
<span class="c1">//输出</span>
<span class="c1">//1:1</span>
<span class="c1">//2:2</span>
<span class="c1">//2:3</span>
<span class="c1">//2:4</span>
<span class="c1">//2:5</span>
<span class="c1">//2:6</span>
<span class="c1">//Uncaught ReferenceError: a is not defined</span>
</pre></div>

<h4 id="_56">参考链接<a class="headerlink" href="#_56" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4" target="_blank">https://juejin.im/entry/5b1d2d54f265da6e2545bfa4</a> </p>
<h2 id="202071">2020/7/1<a class="headerlink" href="#202071" title="Permanent link"></a></h2>
<h3 id="url">输入URL之后的过程<a class="headerlink" href="#url" title="Permanent link"></a></h3>
<ol>
<li>浏览器中输入网址</li>
<li>域名解析（DNS），找到服务器IP地址</li>
<li>发起TCP连接，HTTP三次握手</li>
<li>发送请求（Request）</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h4 id="dns">DNS解析<a class="headerlink" href="#dns" title="Permanent link"></a></h4>
<p>寻找所需资源的IP地址<br />
<strong>过程</strong>  </p>
<ol>
<li>首先在本地的域名服务器中查找，</li>
<li>没找到去根域名服务器查找，</li>
<li>没有再去com顶级域名服务器查找</li>
<li>如此的类推下去，直到找到IP地址，然后把它记录在本地，供下次使用</li>
</ol>
<p>即： <code>.-&gt; .com -&gt;google.com. -&gt; www.google.com.</code> 这个.对应的就是根域名服务器,为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上<br />
<strong>DNS优化</strong><br />
优化DNS解析过程有的消耗和时间的等待  </p>
<ul>
<li>DNS缓存：存在多级缓存，，从缓存获取资源，加快解析速度</li>
<li>DNS负载均衡：访问baidu.com的时候，每次响应的并非是同一个服务器（IP地址不同）。根据用户请求，DNS可以返回一个合适（最近）的机器的IP给用户。</li>
</ul>
<h4 id="tcp">TCP链接、三次握手<a class="headerlink" href="#tcp" title="Permanent link"></a></h4>
<p>TCP报文首部： </p>
<ul>
<li>源端口：源端口和IP地址的作用是标识报文的返回地址。</li>
<li>目的端口：端口指明接收方计算机上的应用程序接口。</li>
</ul>
<p><strong>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</strong></p>
<ul>
<li>确认号：即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</li>
</ul>
<p><strong>确认序号Ack与标志位中的ACK 不同。 确认方Ack=发起方Req+1，两端配对。</strong></p>
<blockquote>
<p>一个是确认值(Acknowledgement)，为1便是确认连接。<br />
另一个是确认编号(Acknowledgement Number)，即接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。<br />
参考自：<a href="https://blog.csdn.net/baiyan3212/article/details/81302448" target="_blank">https://blog.csdn.net/baiyan3212/article/details/81302448</a></p>
</blockquote>
<p><em>注：首部其他字段暂不深入</em></p>
<h4 id="http_1">发送HTTP请求<a class="headerlink" href="#http_1" title="Permanent link"></a></h4>
<p><strong>HTTP的端口为80/8080，而HTTPS的端口为443</strong><br />
请求行的格式为<code>Method Request-URL HTTP-Version CRLF eg: GET index.html HTTP/1.1</code><br />
常用的方法有: <strong>GET,POST, PUT, DELETE, OPTIONS, HEAD</strong>。</p>
<h4 id="http_2">服务器处理请求并返回HTTP报文<a class="headerlink" href="#http_2" title="Permanent link"></a></h4>
<p>响应内容：<strong>状态码 ，响应报头和响应报文</strong>  </p>
<ul>
<li>状态码：由3位数组成，第一个数字定义了响应的类别，且有五种可能取值<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
</li>
<li>常见状态码<ul>
<li>200 成功请求成功，通常服务器提供了需要的资源。</li>
<li>204 无内容，服务器成功处理了请求，但没有返回任何内容。</li>
<li>301 永久移动，请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li>
<li>302 临时移动，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
<li>304 未修改，自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li>
<li>400 错误请求，服务器不理解请求的语法。</li>
<li>401 未授权，请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应</li>
<li>403 禁止，服务器拒绝请求。</li>
<li>404 未找到，服务器找不到请求的网页。</li>
<li>422 无法处理，请求格式正确，但是由于含有语义错误，无法响应</li>
<li>500 服务器内部错误，服务器遇到错误，无法完成请求</li>
</ul>
</li>
<li>响应报头：常见的响应报头字段有: Server, Connection&hellip;</li>
<li>响应报文：从服务器请求的HTML,CSS,JS文件就放在这里面</li>
</ul>
<h4 id="_57">浏览器解析渲染页面<a class="headerlink" href="#_57" title="Permanent link"></a></h4>
<p>Webkit解析渲染页面的过程。  </p>
<ol>
<li>解析HTML形成DOM树</li>
<li>解析CSS形成CSSOM 树</li>
<li>合并DOM树和CSSOM树形成渲染树</li>
<li>浏览器开始渲染并绘制页面  </li>
</ol>
<p>这个过程涉及两个比较重要的概念 <strong>回流和重绘</strong>，DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘（具体见下文）</p>
<h4 id="_58">参考链接<a class="headerlink" href="#_58" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5cc573c85188252e741ccbb6" target="_blank">https://juejin.im/post/5cc573c85188252e741ccbb6</a></p>
<h3 id="_59">浏览器的回流与重绘<a class="headerlink" href="#_59" title="Permanent link"></a></h3>
<ol>
<li>浏览器使用流式布局模型 (Flow Based Layout)。</li>
<li>浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。</li>
<li>有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li>
<li>由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一<br />
<strong>回流必将引起重绘，重绘不一定会引起回流</strong></li>
</ol>
<h4 id="reflow">回流(Reflow)<a class="headerlink" href="#reflow" title="Permanent link"></a></h4>
<p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流
会导致回流的操作：</p>
<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的DOM元素</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
<p>一些常用且会导致回流的属性和方法：</p>
<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>scrollIntoView()、scrollIntoViewIfNeeded()</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
<li>scrollTo()</li>
</ul>
<h4 id="repaint">重绘 (Repaint)<a class="headerlink" href="#repaint" title="Permanent link"></a></h4>
<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘</p>
<h4 id="_60">性能影响和避免<a class="headerlink" href="#_60" title="Permanent link"></a></h4>
<p>回流比重绘的代价要更高。<br />
避免方法   </p>
<ul>
<li>CSS<ul>
<li>避免使用table布局。</li>
<li>尽可能在DOM树的最末端改变class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上。</li>
<li>避免使用CSS表达式（例如：calc()）。</li>
</ul>
</li>
<li>JavaScript<ul>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>
<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
</li>
</ul>
<h4 id="_61">参考链接<a class="headerlink" href="#_61" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank">https://juejin.im/post/5a9923e9518825558251c96a</a></p>
<h3 id="tcp_1">TCP三次握手、四次挥手<a class="headerlink" href="#tcp_1" title="Permanent link"></a></h3>
<h4 id="_62">三次握手<a class="headerlink" href="#_62" title="Permanent link"></a></h4>
<p><img alt="三次握手" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/three.png" />  </p>
<ul>
<li>第一次握手：客户端发送syn包(Seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</li>
</ul>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<h4 id="_63">四次挥手<a class="headerlink" href="#_63" title="Permanent link"></a></h4>
<p><img alt="四次挥手" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/four.png" />  </p>
<ul>
<li>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送此时客户端还可以接受数据。FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>第二次挥手：服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>第三次挥手：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，告诉客户端数据发送完了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过 <strong>2∗MSL（最长报文段寿命）</strong> 的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>
</ul>
<p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h4 id="_64">问题<a class="headerlink" href="#_64" title="Permanent link"></a></h4>
<p><strong>1. 为什么客户端最后还要等待2MSL？</strong><br />
MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。<br />
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<br />
第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<p><strong>2. 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong><br />
建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br />
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<p><strong>3. 为什么会采用三次握手，而不是两次或四次？</strong><br />
(假设主机A为客户端，主机B为服务器端。)采用两次握手不行。采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。<br />
通信不可能100%可靠，而上面的三次握手已经做好了通信的准备工作，再增加握手，并不能显著提高可靠性，而且也没有必要。</p>
<h4 id="_65">参考链接<a class="headerlink" href="#_65" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/entry/5af412eb6fb9a07aa631cc18" target="_blank">https://juejin.im/entry/5af412eb6fb9a07aa631cc18</a></p>
<h2 id="202072">2020/7/2<a class="headerlink" href="#202072" title="Permanent link"></a></h2>
<h3 id="httphttps">HTTP和HTTPS<a class="headerlink" href="#httphttps" title="Permanent link"></a></h3>
<p><strong>OSI（开放式系统互联）七层协议模型</strong>： 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br />
<strong>TCP/IP五层模型</strong>：物理层、数据链路层、网络层、传输层、应用层</p>
<h4 id="_66">计算机通信原理<a class="headerlink" href="#_66" title="Permanent link"></a></h4>
<p>互联网的关键技术就是TCP/IP协议。两台计算机之间的通信是通过TCP/IP协议在因特网上进行的。</p>
<ul>
<li>TCP: Transmission Control Protocol 传输控制协议<br />
  TCP是应用程序之间的通信。<br />
  TCP确保数据包以正确的次序到达，并且尝试确认数据包的内容没有改变。<br />
  当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信，占用两个计算机之间整个的通信线路。<br />
  TCP 用于从应用程序到网络的数据传输控制。<br />
  TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组</li>
<li>IP: Internet Protocol 网际协议。<br />
  IP是计算机之间的通信。<br />
  IP协议是计算机用来相互识别的通信的一种机制，每台计算机都有一个IP用来在internet上标识这台计算机。<br />
  IP 负责在因特网上发送和接收数据包。<br />
  通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。</li>
</ul>
<p><strong>TCP/IP协议</strong><br />
TCP/IP 就是TCP 和 IP 两个协议在一起协同工作，有上下层次的关系。<br />
IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，IP 负责将包发送至接受者，传输过程要经IP路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址，然后在它们到达的时候重新组合它们。<br />
IP协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只检查关键的头数据）。为了提供消息检验功能，直接在IP协议上设计了传输控制协议TCP。</p>
<h4 id="http_3">HTTP<a class="headerlink" href="#http_3" title="Permanent link"></a></h4>
<blockquote>
<p>引自维基百科HTTP:超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。
设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>
</blockquote>
<p>HTTP（HyperText Transfer Protocol）超文本传输协议，是一个基于TCP实现的应用层协议。<br />
HTTP由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP协议永远都是客户端发起请求，服务器回送响应<br />
HTTP是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息  </p>
<ul>
<li>HTTP请求方法<ul>
<li>GET: 获取URL指定的资源；</li>
<li>POST：传输实体信息</li>
<li>PUT：上传文件</li>
<li>DELETE：删除文件</li>
<li>HEAD：获取报文首部，与GET相比，不返回报文主体部分</li>
<li>OPTIONS：询问支持的方法</li>
<li>TRACE：追踪请求的路径；</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信。主要使用SSL和TLS将数据加密后通过网络隧道进行传输。</li>
</ul>
</li>
<li>HTTP响应状态码：(见上文-服务器处理请求并返回HTTP报文)</li>
<li>HTTP缺点<ul>
<li>通信使用明文，可能被窃听</li>
<li>不验证通信方的身份，可能遭遇伪装</li>
<li>无法证明报文的完整性，有可能遭遇篡改</li>
</ul>
</li>
</ul>
<h4 id="https">HTTPS<a class="headerlink" href="#https" title="Permanent link"></a></h4>
<p>HTTP+加密+认证+完整性保护 = HTTPS  </p>
<blockquote>
<p>引自维基百科HTTPS：超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。</p>
</blockquote>
<p>HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生<br />
TLS/SSL全称 <strong>安全传输层协议</strong>Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造<br />
<img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/https.png" /><br />
HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是：</p>
<ul>
<li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</li>
<li>对网站服务器进行真实身份认证</li>
</ul>
<h5 id="tlsssl">TLS/SSL工作原理<a class="headerlink" href="#tlsssl" title="Permanent link"></a></h5>
<p><strong>HTTPS加密过程：</strong>  </p>
<p><img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/jiami.png" />  </p>
<p>HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：<strong>散列函数Hash、对称加密和非对称加密</strong>，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性  </p>
<p><img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/TLS%26SSL.png" /></p>
<ul>
<li>散列函数Hash:常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性。在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密。  <ul>
<li>信息摘要：将公钥和信息用一个 Hash 算法生成的</li>
</ul>
</li>
<li>对称加密:常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是 <strong>1对1</strong>。  <ul>
<li>优点：运算速度快</li>
<li>缺点：密钥容易被获取</li>
</ul>
</li>
<li>非对称加密：即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。非对称加密的特点是信息传输 <strong>1对多</strong>，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。<ul>
<li>优点：更安全</li>
<li>缺点：运算速度慢</li>
</ul>
</li>
</ul>
<p><strong>结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</strong> </p>
<p>SSL握手过程：  </p>
<ol>
<li>客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份；  </li>
<li>互相传递三个随机数，之后通过这三个随机数来生成一个密钥；  </li>
<li>互相确认密钥，然后握手结束；  </li>
<li>数据通讯开始，都使用同一个对话密钥来加解密；  </li>
</ol>
<p><img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/SSLwoshou.png" />  </p>
<h5 id="pki">PKI体系<a class="headerlink" href="#pki" title="Permanent link"></a></h5>
<p>身份验证和密钥协商是TLS的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但RSA算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息  </p>
<p><img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/RSA.png" />  </p>
<p>解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA(如沃通CA)。CA 负责核实公钥的拥有者的信息，并颁发认证&rdquo;证书&rdquo;，同时能够为使用者提供证书验证服务，即 <strong>PKI体系</strong>(PKI基础知识)。<br />
基本的原理为，CA负责审核信息，然后对关键信息利用私钥进行&rdquo;签名&rdquo;，公开对应的公钥，客户端可以利用公钥验证签名。CA也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。<br />
<img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/PKI.png" />  </p>
<ol>
<li>服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li>
<li>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li>
<li>如信息审核通过，CA会向申请者签发认证文件-证书（证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文）。同时包含一个签名;签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用CA的私钥对信息摘要进行加密，密文即签名;</li>
<li>客户端 C 向服务器 S 发出请求时，S 返回证书文件(.证书=公钥+申请者与颁发者信息+签名);</li>
<li>客户端 C 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法;</li>
<li>客户端然后验证证书相关的域名信息、有效时间等信息;</li>
<li>客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</li>
</ol>
<h4 id="https_1">HTTPS性能损耗与优化<a class="headerlink" href="#https_1" title="Permanent link"></a></h4>
<ul>
<li>损耗<ul>
<li>增加延时：一次完整的握手至少需要两端依次来回两次通信，至少增加延时2* RTT，利用会话缓存从而复用连接，延时也至少1* RTT<br />
基于 TCP 单次握手的往返时间. 连接的往返时间成为 <code>RTT</code> (Round Trip Time)</li>
<li>消耗较多的CPU资源：RSA的解密耗费资源大</li>
</ul>
</li>
<li>优化<ul>
<li>CDN接入：HTTPS 增加的延时主要是传输延时 RTT，RTT 的特点是节点越近延时越小，CDN 天然离用户最近，因此选择使用 CDN 作为 HTTPS 接入的入口，将能够极大减少接入延时  </li>
<li>会话缓存：基于会话缓存建立的 HTTPS 连接不需要服务器使用RSA私钥解密获取 Pre-master 信息，可以省去CPU 的消耗</li>
<li>硬件加速</li>
<li>远程解密：考虑将最消耗 CPU 资源的RSA解密计算任务转移到其它服务器，如此则可以充分发挥服务器的接入能力，充分利用带宽与网卡资源</li>
<li>SPDY/HTTP2：SPDY/HTTP2 利用 TLS/SSL 带来的优势，通过修改协议的方法来提升 HTTPS 的性能，提高下载速度等</li>
</ul>
</li>
</ul>
<h4 id="_67">参考链接<a class="headerlink" href="#_67" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5af557a3f265da0b9265a498" target="_blank">https://juejin.im/post/5af557a3f265da0b9265a498</a><br />
<a href="https://yuqirong.me/2018/03/03/HTTPS%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/" target="_blank">https://yuqirong.me/2018/03/03/HTTPS%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</a><br />
<a href="https://juejin.im/post/5dbff8456fb9a02050548815" target="_blank">https://juejin.im/post/5dbff8456fb9a02050548815</a></p>
<h2 id="202073">2020/7/3<a class="headerlink" href="#202073" title="Permanent link"></a></h2>
<h3 id="http10http11-http20">HTTP1.0、HTTP1.1 和 HTTP2.0<a class="headerlink" href="#http10http11-http20" title="Permanent link"></a></h3>
<p>早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器  </p>
<h4 id="http_4">HTTP的基本优化<a class="headerlink" href="#http_4" title="Permanent link"></a></h4>
<p>影响一个 HTTP 网络请求的因素主要有两个：<strong>带宽和延迟</strong>。</p>
<ul>
<li>带宽：现在网络基础建设已经使得带宽得到极大的提升，不用再担心由带宽而影响网速</li>
<li>延迟<ul>
<li>浏览器阻塞（HOL blocking）：浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞</li>
<li>DNS 查询（DNS Lookup）：可以利用DNS缓存和DNS负载均衡来优化（见上文DNS解析）</li>
<li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。<br />
<strong>慢启动</strong>的总体思路就是从一个很低的初始值开始，逐渐增加数据发送的速度，直到达到超时或者丢包为止。在没有出现超时或者丢包时，慢启动增长的速度是指数级的，所以慢启动实际上并没有那么“慢”，“慢”是慢在它的起点只有1个MSS</li>
</ul>
</li>
</ul>
<h4 id="http10http11">HTTP1.0和HTTP1.1的区别<a class="headerlink" href="#http10http11" title="Permanent link"></a></h4>
<ul>
<li>缓存处理 <br />
在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li>带宽优化及网络连接的使用<br />
HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>错误通知的管理<br />
在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>Host头处理<br />
在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
<li>长连接<br />
HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive ，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点<br />
<strong>长连接</strong>便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。</li>
</ul>
<h4 id="http1011">HTTP1.0和1.1现存的一些问题<a class="headerlink" href="#http1011" title="Permanent link"></a></h4>
<p><strong>高延迟&ndash;带来页面加载速度的降低、无状态特性&ndash;带来的巨大HTTP头部、明文传输&ndash;带来的不安全性、不支持服务器推送消息</strong>  </p>
<ul>
<li>HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。</li>
<li>HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li>
<li>HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。</li>
<li>虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间</li>
</ul>
<h4 id="spdyhttp1x">SPDY:HTTP1.x的优化<a class="headerlink" href="#spdyhttp1x" title="Permanent link"></a></h4>
<p><strong>SPDY方案</strong>，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性。<br />
SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。   </p>
<p><img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/SPDY.png" />  </p>
<ul>
<li><strong>降低延迟</strong>：针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking(浏览器阻塞)的问题，降低了延迟同时提高了带宽的利用率。</li>
<li><strong>请求优先级（request prioritization）</strong>：多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li>
<li><strong>header压缩</strong>：HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li>
<li><strong>基于HTTPS的加密协议传输</strong>：大大提高了传输数据的可靠性。</li>
<li><strong>服务端推送（server push）</strong>：采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了</li>
</ul>
<h4 id="http20">HTTP2.0的新特性<a class="headerlink" href="#http20" title="Permanent link"></a></h4>
<p>SPDY 协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承  </p>
<ul>
<li><strong>新的二进制格式（Binary Format）</strong>：HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。二进制则不同，只认0和1的组合。在 HTTP/2 中，有两个非常重要的概念，分别是 <strong>帧（frame）</strong> 和 <strong>流（stream）</strong>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
HTTP2 采用二进制数据帧传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。</li>
<li><strong>header压缩</strong>： HTTP1.x 的 header 带有大量信息，而且每次都要重复发送。例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销<br />
<img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/header.png" /><br />
<strong>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩</strong></li>
<li><strong>多路复用（MultiPlexing）</strong>：即连接共享。<ul>
<li>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。</li>
<li>并行交错地发送多个请求/响应，请求/响应之间互不影响。</li>
</ul>
</li>
<li><strong>服务端推送（server push）</strong>：HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为&rdquo;服务器推送&rdquo;（ Server Push，也叫 Cache push）</li>
</ul>
<p>HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：</p>
<ul>
<li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>
<li>HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE</li>
</ul>
<h4 id="_68">参考链接<a class="headerlink" href="#_68" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5d9abde7e51d4578110dc77f" target="_blank">https://juejin.im/post/5d9abde7e51d4578110dc77f</a><br />
<a href="https://juejin.im/entry/57b17d107db2a200542da15b" target="_blank">https://juejin.im/entry/57b17d107db2a200542da15b</a><br />
<a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank">https://juejin.im/entry/5981c5df518825359a2b9476</a>  </p>
<h2 id="202076">2020/7/6<a class="headerlink" href="#202076" title="Permanent link"></a></h2>
<h3 id="sessionstorage-localstorage">sessionStorage 和 localStorage<a class="headerlink" href="#sessionstorage-localstorage" title="Permanent link"></a></h3>
<p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中（同一窗口或标签页）的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储<br />
localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的<br />
localStorage 和 sessionStorage 属性允许在浏览器中存储 key/value 对的数据<br />
localStorage 只支持 string 类型的存储
<div class="highlight"><pre><span class="c1">//localStorage有三种写法</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;浏览器不支持localstorage&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="kd">var</span> <span class="nx">storage</span><span class="o">=</span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">;</span>
    <span class="c1">//写入a字段</span>
    <span class="nx">storage</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="c1">//写入b字段</span>
    <span class="nx">storage</span><span class="p">.</span><span class="nx">b</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="c1">//写入c字段</span>
    <span class="nx">storage</span><span class="p">.</span><span class="nx">setItem</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">storage</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]);</span><span class="c1">//string</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">storage</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]);</span><span class="c1">//string</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">storage</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]);</span><span class="c1">//string</span>
    <span class="c1">//第一种方法读取</span>
    <span class="kd">var</span> <span class="nx">a</span><span class="o">=</span><span class="nx">storage</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="c1">//第二种方法读取</span>
    <span class="kd">var</span> <span class="nx">b</span><span class="o">=</span><span class="nx">storage</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">];</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
    <span class="c1">//第三种方法读取</span>
    <span class="kd">var</span> <span class="nx">c</span><span class="o">=</span><span class="nx">storage</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="webpackvue-cli-proxytable">webpack/Vue-cli 利用proxyTable跨域<a class="headerlink" href="#webpackvue-cli-proxytable" title="Permanent link"></a></h3>
<p><strong>webpack是前端资源模块化管理和打包的工具</strong>，它可以把松散的资源根据依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分割，等到实际需要的时候再加载。把浏览器不能识别的东西如（less，scss）等转换为浏览器可以识别的语言如（css），因为vue中需要引入大量的各种各样的模块 所以很依赖webpack。在webpack看来 一切皆模块。<br />
<strong>vue-cli是脚手架工具</strong>。他可以帮助我们用配置好的模板快速搭建起一个项目工程来。省去了自己再去配置webpack配置文件的基本内容。  </p>
<p>在平时项目的开发环境中，经常会遇到跨域的问题，尤其是使用vue-cli这种脚手架工具开发时，由于项目本身启动本地服务是需要占用一个端口的，所以必然会产生跨域的问题<br />
使用webpack做构建工具的项目中使用proxyTable代理实现跨域是一种比较方便的选择<br />
使用的插件<a href="https://github.com/chimurai/http-proxy-middleware" target="_blank">http-proxy-middleware</a><br />
<em>注：此方法仅限用于开发环境，不适合生产环境，生产环境可以用nginx进行代理</em>
<div class="highlight"><pre><span class="c1">//根目录下config文件夹下的index.js文件</span>
<span class="c1">//由于在开发环境下使用，所以配置在dev里面</span>
<span class="nx">dev</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">assetsRoot</span><span class="o">:</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="s2">&quot;../dist&quot;</span><span class="p">),</span>
    <span class="nx">assetsSubDirectory</span><span class="o">:</span> <span class="s2">&quot;static&quot;</span><span class="p">,</span><span class="c1">// 静态资源文件夹</span>
    <span class="nx">assetsPublicPath</span><span class="o">:</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span><span class="c1">// 发布路径</span>
    <span class="nx">host</span><span class="o">:</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span><span class="c1">// Various Dev Server settings</span>
    <span class="nx">port</span><span class="o">:</span> <span class="mi">8080</span><span class="p">,</span><span class="c1">// dev-server监听的端口</span>
    <span class="nx">autoOpenBrowser</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">proxyTable</span><span class="o">:</span> <span class="p">{</span>
    <span class="s1">&#39;/api&#39;</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">target</span><span class="o">:</span> <span class="s1">&#39;http://www.abc.com&#39;</span><span class="p">,</span>  <span class="c1">//目标接口域名</span>
      <span class="nx">changeOrigin</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>  <span class="c1">//是否跨域，开启代理</span>
      <span class="c1">// secure: false,  // 如果是https接口，需要配置这个参数</span>
      <span class="nx">pathRewrite</span><span class="o">:</span> <span class="p">{</span>
        <span class="s1">&#39;^/api&#39;</span><span class="o">:</span> <span class="s1">&#39;/api&#39;</span>   <span class="c1">//重写接口</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">cssSourceMap</span><span class="o">:</span> <span class="kc">false</span> <span class="c1">//是否使用 cssSourceMap</span>
<span class="p">}</span>
</pre></div>
上面这段代码的效果就是将本地8080端口的一个请求代理到了 <a href="http://www.abc.com">www.abc.com</a> 这个域名下：</p>
<p><code>'http://localhost:8080/api' =&gt; 'http://www.abc.com/api'</code></p>
<h4 id="_69">参考链接<a class="headerlink" href="#_69" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/wancheng7/p/8987694.html" target="_blank">https://www.cnblogs.com/wancheng7/p/8987694.html</a><br />
<a href="https://juejin.im/post/5da13dc0e51d45780f060508" target="_blank">https://juejin.im/post/5da13dc0e51d45780f060508</a></p>
<h3 id="nodejsrequirepathresolve">nodejs的require和path.resolve()<a class="headerlink" href="#nodejsrequirepathresolve" title="Permanent link"></a></h3>
<h4 id="node-require">node require<a class="headerlink" href="#node-require" title="Permanent link"></a></h4>
<p>node中采用了两个核心模块来管理模块依赖：</p>
<ul>
<li>require模块：全局可见，不需要额外使用require(&lsquo;require&rsquo;)</li>
<li>module模块：全局可见，不需要额外使用require(&lsquo;module&rsquo;)</li>
</ul>
<p>当require()函数传入一个path参数的时候，node会依次执行如下步骤：</p>
<ol>
<li>Resolving : 找到path的绝对路径。</li>
<li>Loading: 确定文件的内容。</li>
<li>Wrapping：构造私有的作用域。Wrapping可以确保每次require文件的时候，require和exports都是私有的。</li>
<li>Evaluating：evaluating环节是VM处理已加载文件的最后一个环节。</li>
<li>Caching：为了避免引用相同的文件情况下，不重复执行上面的步骤</li>
</ol>
<h4 id="nodepathresolve__dirnamesrc">Node的path.resolve(__dirname，&rsquo;./src&rsquo;)<a class="headerlink" href="#nodepathresolve__dirnamesrc" title="Permanent link"></a></h4>
<ol>
<li>path.resolve( )方法<br />
只想解析模块但不执行模块,可以使用require.resolve函数<br />
<code>path.resolve([...paths])</code><br />
传入参数：&hellip;paths是传入的字符串参数，是路径序列或者路径片段。<br />
返回值：字符串<br />
使用方法：<ol>
<li>path.resolve()方法可以将路径或者路径片段解析成绝对路径</li>
<li>传入路径从右至左解析，遇到第一个绝对路径是完成解析，例如<code>path.resolve('/foo', '/bar', 'baz') 将返回 /bar/baz</code></li>
<li>如果传入的绝对路径不存在，那么当前目录将被使用</li>
<li>当传入的参数没有/时，将被传入解析到当前根目录</li>
<li>零长度的路径将被忽略</li>
<li>如果没有传入参数，将返回当前根目录</li>
</ol>
</li>
</ol>
<p>具体跳转路径如下图所示：
<img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/nodeTest.png" /></p>
<blockquote>
<p>../dist:相当于在__dirname父目录下执行 CD  dist<br />
./dist:相当于在__dirname目录下执行 CD  dist<br />
/dist：和_dirname无关，在根目录执行 cd dist<br />
dist:和_dirname无关，直接 CD dist的目录</p>
</blockquote>
<ol start="2">
<li>__dirname变量
在任何模块文件内部，可以使用__dirname变量获取当前模块文件所在目录的完整绝对路径  </li>
</ol>
<p><div class="highlight"><pre><span class="kd">var</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">);</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span><span class="s1">&#39;./src&#39;</span><span class="p">))</span>
<span class="c1">// /Users/frank/Desktop/sfs-blog</span>
<span class="c1">// /Users/frank/Desktop/sfs-blog/src</span>
</pre></div>
<strong>使用场景：</strong>
<div class="highlight"><pre><span class="c1">//webpack配置build/webpack.dev.conf.js：</span>
  <span class="nx">resolve</span><span class="o">:</span><span class="p">{</span>
    <span class="c1">//解析扩展名</span>
    <span class="nx">extensions</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;.js&#39;</span><span class="p">,</span><span class="s1">&#39;vue&#39;</span><span class="p">],</span>
    <span class="nx">alias</span><span class="o">:</span> <span class="p">{</span>
      <span class="c1">//快捷访问入口</span>
      <span class="s1">&#39;util&#39;</span><span class="o">:</span><span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span><span class="s1">&#39;./src/util&#39;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/*上述代码在引用文件的时候：</span>
<span class="cm">  修改之前：import foo from &quot;../../../util/foo&quot;</span>
<span class="cm">  修改之后：import foo from &quot;util/foo&quot;</span>
<span class="cm">  可以便捷引用文件*/</span>
</pre></div></p>
<h4 id="_70">参考链接<a class="headerlink" href="#_70" title="Permanent link"></a></h4>
<p><a href="https://www.jianshu.com/p/76966243f27f" target="_blank">https://www.jianshu.com/p/76966243f27f</a><br />
<a href="https://blog.csdn.net/CarryBest/article/details/88813745" target="_blank">https://blog.csdn.net/CarryBest/article/details/88813745</a></p>
<h2 id="202078">2020/7/8<a class="headerlink" href="#202078" title="Permanent link"></a></h2>
<h3 id="ajaxjquery-ajax-axios-fetch">ajax、jquery ajax、 axios、 fetch<a class="headerlink" href="#ajaxjquery-ajax-axios-fetch" title="Permanent link"></a></h3>
<h4 id="ajax">ajax<a class="headerlink" href="#ajax" title="Permanent link"></a></h4>
<p>最早出现的发送后端请求技术，隶属于原始js中，核心使用XMLHttpRequest对象。  </p>
<p><img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/ajax.png" /></p>
<p><div class="highlight"><pre><span class="kd">function</span> <span class="nx">reqListener</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">responseText</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">oReq</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">oReq</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">reqListener</span><span class="p">;</span>
<span class="nx">oReq</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&quot;get&quot;</span><span class="p">,</span> <span class="s2">&quot;newFile.txt&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">oReq</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
</pre></div>
通过XMLHttpRequest生成的请求可以有两种方式来获取数据，异步模式或同步模式。请求的类型是由这个XMLHttpRequest对象的open()方法的第三个参数async的值决定的。如果该参数的值为 false，则该XMLHttpRequest请求以同步模式进行，否则该过程将以异步模式完成。<br />
XMLHttpRequest一般用来发送和接收文本数据，但其实也可以发送和接受二进制内容，处理二进制数据的方法：<code>XMLHttpRequest.overrideMimeType()</code> 和 <code>responseType 属性</code>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">oReq</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>

<span class="nx">oReq</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">arraybuffer</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">;</span> <span class="c1">// not responseText</span>
<span class="p">}</span>
<span class="nx">oReq</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">oReq</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s2">&quot;arraybuffer&quot;</span><span class="p">;</span>
<span class="nx">oReq</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
</pre></div>
<strong>XMLHttpRequest提交表单</strong>  </p>
<ul>
<li>使用 AJAX：是最复杂的但也是最灵活和最强大</li>
<li>使用 FormData API ：最简单最快捷的，但是缺点是被收集的数据无法使用 JSON.stringify() 转换为一个 JSON 字符串</li>
</ul>
<h4 id="jquery-ajax">Jquery Ajax<a class="headerlink" href="#jquery-ajax" title="Permanent link"></a></h4>
<p><div class="highlight"><pre><span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
  <span class="nx">url</span><span class="o">:</span> <span class="s2">&quot;/api/getWeather&quot;</span><span class="p">,</span>
  <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">zipcode</span><span class="o">:</span> <span class="mi">97201</span>
  <span class="p">},</span>
  <span class="nx">success</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">result</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span> <span class="s2">&quot;#weather-temp&quot;</span> <span class="p">).</span><span class="nx">html</span><span class="p">(</span> <span class="s2">&quot;&lt;strong&gt;&quot;</span> <span class="o">+</span> <span class="nx">result</span> <span class="o">+</span> <span class="s2">&quot;&lt;/strong&gt; degrees&quot;</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
Jquery Ajax的出现是对原生XHR的封装，除此以外还增添了对JSONP的支持。<br />
不足：  </p>
<ol>
<li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>
<li>基于原生的XHR开发，XHR本身的架构不清晰,已经有了fetch的替代方案</li>
<li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>
<li>不符合关注分离（Separation of Concerns）的原则</li>
<li>配置和调用方式非常混乱，而且基于事件的异步模型不友好</li>
</ol>
<h4 id="axios">axios<a class="headerlink" href="#axios" title="Permanent link"></a></h4>
<p><div class="highlight"><pre><span class="c1">//执行多个并发请求</span>
<span class="kd">function</span> <span class="nx">getUserAccount</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">axios</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/user/12345&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getUserPermissions</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">axios</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/user/12345/permissions&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">axios</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">getUserAccount</span><span class="p">(),</span> <span class="nx">getUserPermissions</span><span class="p">()])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">axios</span><span class="p">.</span><span class="nx">spread</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">acct</span><span class="p">,</span> <span class="nx">perms</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 两个请求现在都执行完成</span>
  <span class="p">}));</span>
</pre></div>
Axios本质上也是对原生XHR的封装，只不过它是Promise的实现版本，可以用在浏览器和 node.js 中<br />
<strong>特性：</strong></p>
<ul>
<li>从浏览器中创建 XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
<p>axios创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。</p>
<h4 id="fetch">fetch<a class="headerlink" href="#fetch" title="Permanent link"></a></h4>
<blockquote>
<p>Fetch 提供了对 Request 和 Response （以及其他与网络请求有关的）对象的通用定义。
Fetch 是一个现代的概念, 等同于 XMLHttpRequest。它提供了许多与XMLHttpRequest相同的功能，但被设计成更具可扩展性和高效性。</p>
</blockquote>
<p>fetch规范与jQuery.ajax()主要有两种方式的不同:</p>
<ul>
<li>当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li>
<li>默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。自从2017年8月25日后，默认的credentials政策变更为same-originFirefox也在61.0b13中改变默认值</li>
</ul>
<p><div class="highlight"><pre><span class="c1">// Example POST method implementation:</span>

<span class="nx">postData</span><span class="p">(</span><span class="s1">&#39;http://example.com/answer&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">answer</span><span class="o">:</span> <span class="mi">42</span><span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="c1">// JSON from `response.json()` call</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">))</span>

<span class="kd">function</span> <span class="nx">postData</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Default options are marked with *</span>
  <span class="k">return</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">body</span><span class="o">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="c1">// must match &#39;Content-Type&#39; header</span>
    <span class="nx">cache</span><span class="o">:</span> <span class="s1">&#39;no-cache&#39;</span><span class="p">,</span> <span class="c1">// *default, no-cache, reload, force-cache, only-if-cached</span>
    <span class="nx">credentials</span><span class="o">:</span> <span class="s1">&#39;same-origin&#39;</span><span class="p">,</span> <span class="c1">// include, same-origin, *omit</span>
    <span class="nx">headers</span><span class="o">:</span> <span class="p">{</span>
      <span class="s1">&#39;user-agent&#39;</span><span class="o">:</span> <span class="s1">&#39;Mozilla/4.0 MDN Example&#39;</span><span class="p">,</span>
      <span class="s1">&#39;content-type&#39;</span><span class="o">:</span> <span class="s1">&#39;application/json&#39;</span>
    <span class="p">},</span>
    <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="c1">// *GET, POST, PUT, DELETE, etc.</span>
    <span class="nx">mode</span><span class="o">:</span> <span class="s1">&#39;cors&#39;</span><span class="p">,</span> <span class="c1">// no-cors, cors, *same-origin</span>
    <span class="nx">redirect</span><span class="o">:</span> <span class="s1">&#39;follow&#39;</span><span class="p">,</span> <span class="c1">// manual, *follow, error</span>
    <span class="nx">referrer</span><span class="o">:</span> <span class="s1">&#39;no-referrer&#39;</span><span class="p">,</span> <span class="c1">// *client, no-referrer</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span> <span class="c1">// parses response to JSON</span>
<span class="p">}</span>
</pre></div>
fetch的优点：  </p>
<ol>
<li>语法简洁，更加语义化</li>
<li>基于标准 Promise 实现，支持 async/await</li>
<li>同构方便，使用 isomorphic-fetch</li>
<li>更加底层，提供的API丰富（request, response）</li>
<li>脱离了XHR，是ES规范里新的实现方式</li>
</ol>
<p><strong>fetch在前端的应用上有一项xhr怎么也比不上的能力：跨域的处理</strong><br />
fetch中可以设置mode为&rdquo;no-cors&rdquo;（不跨域）。这样之后我们会得到一个type为“opaque”的返回。需要指出的是，这个请求是真正抵达过后台的，所以我们可以使用这种方法来进行信息上报</p>
<h4 id="_71">参考链接<a class="headerlink" href="#_71" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5d5e673ff265da03d2114646" target="_blank">https://juejin.im/post/5d5e673ff265da03d2114646</a></p>
<h2 id="202079">2020/7/9<a class="headerlink" href="#202079" title="Permanent link"></a></h2>
<h3 id="javascript">javaScript闭包<a class="headerlink" href="#javascript" title="Permanent link"></a></h3>
<h4 id="_72">作用域与词法作用域<a class="headerlink" href="#_72" title="Permanent link"></a></h4>
<p><strong>作用域</strong>就是一套规则，用于确定在何处以及如何查找变量（标识符）的规则，通俗的讲，作用域就是查找变量的地方<br />
<strong>作用域链</strong>：在查找某变量的时候，先在函数作用域中查找，没有找到，再去全局作用域中查找，有一个往外层查找的过程。好像是顺着一条链条从下往上查找变量，这条链条，就称之为作用域链<br />
<strong>词法作用域</strong>就是作用域是由书写代码时函数声明的位置来决定的<br />
一般来说，在编程语言里我们常见的变量作用域就是 <strong>词法作用域</strong>与 <strong>动态作用域</strong> (Dynamic Scope) ，绝大部分的编程语言都是使用的词法作用域。词法作用域注重的是所谓的Write-Time，即 <strong>编程时的上下文</strong>，而动态作用域以及常见的this的用法，都是Run-Time，即 <strong>运行时上下文</strong>。词法作用域关注的是函数在何处被定义，而动态作用域关注的是函数在何处被调用</p>
<h4 id="_73">闭包<a class="headerlink" href="#_73" title="Permanent link"></a></h4>
<p>定义：</p>
<ul>
<li>定义一：闭包是指有权访问另一个函数作用域中的变量的函数；</li>
<li>定义二：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。  </li>
</ul>
<p><div class="highlight"><pre><span class="kd">function</span> <span class="nx">fn1</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;iceman&#39;</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">fn2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fn2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">fn3</span> <span class="o">=</span> <span class="nx">fn1</span><span class="p">();</span>
<span class="nx">fn3</span><span class="p">();</span>
</pre></div>
fn3就是fn2函数本身。执行fn3能正常输出name，这不就是fn2能记住并访问它所在的词法作用域，而且fn2函数的运行还是在当前词法作用域之外了<br />
正常来说，当fn1函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放那段内存空间。而闭包却很神奇的将fn1的作用域存活了下来，fn2依然持有该作用域的引用，这个引用就是闭包。<br />
（<em>闭包应用可参考上文  <strong>防抖与节流</strong> 处</em>）<br />
典型闭包实例：
<div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
解决办法：
<div class="highlight"><pre><span class="c1">//方法1</span>
<span class="c1">//让i在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前i的值</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">j</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="p">})();</span>
<span class="p">}</span>
<span class="c1">//方法2</span>
<span class="c1">//将每次迭代的i作为实参传递给自执行函数，自执行函数中用变量去接收</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">j</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></p>
<p><strong>自执行函数或是自调用函数</strong> :声明完了，马上进行调用，只能使用一次<br />
闭包的缺点：</p>
<ul>
<li>闭包的缺点就是常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露。</li>
<li>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗</li>
</ul>
<h4 id="_74">参考链接<a class="headerlink" href="#_74" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/5afb0ae56fb9a07aa2138425" target="_blank">https://juejin.im/post/5afb0ae56fb9a07aa2138425</a><br />
<a href="https://juejin.im/entry/57b97480d342d3005acb5758" target="_blank">https://juejin.im/entry/57b97480d342d3005acb5758</a></p>
<h3 id="curry">函数柯里化（curry）<a class="headerlink" href="#curry" title="Permanent link"></a></h3>
<h4 id="_75">柯里化<a class="headerlink" href="#_75" title="Permanent link"></a></h4>
<p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<br />
柯里化，可以理解为提前接收部分参数，延迟执行，不立即输出结果，而是返回一个接受剩余参数的函数。因为这样的特性，也被称为部分计算函数。柯里化，是一个逐步接收参数的过程。<br />
柯里化(Currying)具有：延迟计算（采用 <strong>闭包</strong>的方式）、参数复用、动态生成函数的作用
实例代码：<br />
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">length</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="nx">args</span> <span class="o">=</span> <span class="nx">args</span> <span class="o">||</span> <span class="p">[];</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">_args</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="nx">arg</span><span class="p">,</span> <span class="nx">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">arg</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="nx">_args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">_args</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">curry</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">_args</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">_args</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]);</span>
<span class="p">});</span>
<span class="nx">fn</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">)</span> <span class="c1">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="nx">fn</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">)(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span> <span class="c1">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="nx">fn</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)(</span><span class="s2">&quot;b&quot;</span><span class="p">)(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span> <span class="c1">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="nx">fn</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">)</span> <span class="c1">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</pre></div></p>
<h4 id="_76">反柯里化<a class="headerlink" href="#_76" title="Permanent link"></a></h4>
<p>(啊，这个好难懂，先放着吧，以后有时间再学习&hellip;)</p>
<h4 id="_77">参考链接<a class="headerlink" href="#_77" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/598d0b7ff265da3e1727c491" target="_blank">https://juejin.im/post/598d0b7ff265da3e1727c491</a><br />
<a href="https://juejin.im/entry/5884efee128fe1006c3b64d5" target="_blank">https://juejin.im/entry/5884efee128fe1006c3b64d5</a><br />
<a href="https://juejin.im/post/5b561426518825195f499772" target="_blank">https://juejin.im/post/5b561426518825195f499772</a></p>
<h2 id="2020713">2020/7/13<a class="headerlink" href="#2020713" title="Permanent link"></a></h2>
<h3 id="vue_3">vue修饰符<a class="headerlink" href="#vue_3" title="Permanent link"></a></h3>
<h4 id="_78">表单修饰符<a class="headerlink" href="#_78" title="Permanent link"></a></h4>
<ul>
<li>.lazy</li>
<li>.trim  过滤首尾的空格,中间的不会过滤</li>
<li>.number</li>
</ul>
<h4 id="_79">事件修饰符<a class="headerlink" href="#_79" title="Permanent link"></a></h4>
<ul>
<li>.stop: 阻止单击事件冒泡。由于事件冒泡的机制，我们给元素绑定点击事件的时候，也会触发父级的点击事件。
<div class="highlight"><pre>//只执行  fun2  函数
<span class="p">&lt;</span><span class="nt">div</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&quot;fun1()&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">button</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">stop</span><span class="o">=</span><span class="s">&quot;fun2()&quot;</span><span class="p">&gt;</span>ok<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div></li>
<li>.prevent: 用于阻止事件的默认行为,可以使提交事件不再重载页面
<div class="highlight"><pre><span class="c">&lt;!--</span> <span class="nx">提交事件不再重载页面</span> <span class="o">--&gt;</span>
<span class="o">&lt;</span><span class="nx">form</span> <span class="nx">v</span><span class="o">-</span><span class="nx">on</span><span class="o">:</span><span class="nx">submit</span><span class="p">.</span><span class="nx">prevent</span><span class="o">=</span><span class="s2">&quot;onSubmit&quot;</span><span class="o">&gt;&lt;</span><span class="err">/form&gt;</span>
</pre></div></li>
<li>.self: 只当事件是从事件绑定的元素本身触发时才触发回调
级的点击事件。
<div class="highlight"><pre>//只有点击button以外的div部分才会触发 fun1 函数
<span class="p">&lt;</span><span class="nt">div</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">self</span><span class="o">=</span><span class="s">&quot;fun1()&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">button</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&quot;fun2()&quot;</span><span class="p">&gt;</span>ok<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div></li>
<li>.once: 绑定事件只能触发一次</li>
<li>.capture: 事件的冒泡，其实完整的事件机制是：捕获阶段&ndash;目标阶段&ndash;冒泡阶段。.capture使事件触发从包含这个元素的顶层开始往下触发。
<div class="highlight"><pre>//执行顺序为： fun1-&gt;fun2-&gt;fun4-&gt;fun3
//不加capture执行顺序为：fun4-&gt;fun3-&gt;fun2-&gt;fun1
<span class="p">&lt;</span><span class="nt">div</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">capture</span><span class="o">=</span><span class="s">&quot;fun1()&quot;</span><span class="p">&gt;</span>
  obj1
  <span class="p">&lt;</span><span class="nt">div</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">capture</span><span class="o">=</span><span class="s">&quot;fun2()&quot;</span><span class="p">&gt;</span>
    obj2
    <span class="p">&lt;</span><span class="nt">div</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&quot;fun3()&quot;</span><span class="p">&gt;</span>
      obj3
      <span class="p">&lt;</span><span class="nt">div</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&quot;fun4()&quot;</span><span class="p">&gt;</span>
        obj4
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div></li>
<li>.passive: 当我们在滚动页面的时候（通常是我们监听touch事件的时候），页面其实会有一个短暂的停顿（大概200ms），浏览器不知道我们是否要preventDefault，所以它需要一个延迟来检测。这就导致了我们的滑动显得比较卡顿。.passive可以阻止preventDefault事件。可用于移动端页面优化</li>
<li>.native: 有些组件绑定事件不会生效如：<code>&lt;My-component @click="fun()"&gt;&lt;/My-component&gt;</code>。加上.native可以使之生效，可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，注意：使用.native修饰符来操作普通HTML标签是会令事件失效的。</li>
</ul>
<h4 id="_80">鼠标按钮修饰符<a class="headerlink" href="#_80" title="Permanent link"></a></h4>
<ul>
<li>.left 左键点击</li>
<li>.right 右键点击</li>
<li>.middle 中键点击</li>
</ul>
<h4 id="_81">键盘修饰符<a class="headerlink" href="#_81" title="Permanent link"></a></h4>
<p>略</p>
<h4 id="v-bind">v-bind 修饰符<a class="headerlink" href="#v-bind" title="Permanent link"></a></h4>
<ul>
<li>.sync: 父子组件数据双向绑定（简化代码）<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank">官方说明</a> <ul>
<li>子组件传递的事件名必须为update:value
<div class="highlight"><pre><span class="c1">//父组件</span>
<span class="o">&lt;</span><span class="nx">child</span>
  <span class="o">:</span><span class="nx">visible</span><span class="o">=</span><span class="s1">&#39;dialogShow&#39;</span>
  <span class="err">@</span><span class="nx">update</span><span class="o">:</span><span class="nx">visible</span><span class="o">=</span><span class="s2">&quot;val =&gt; dialogShow = val&quot;</span>
<span class="o">&gt;&lt;</span><span class="err">/child&gt;</span>

<span class="c1">//子组件</span>
<span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
<span class="p">...</span>
<span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">visible</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nb">Boolean</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="nx">handleClose</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">&#39;update:visible&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>
</pre></div>
或(简化上面代码)
<div class="highlight"><pre>//父组件
<span class="p">&lt;</span><span class="nt">comp</span> <span class="na">:myMessage</span><span class="err">.</span><span class="na">sync</span><span class="o">=</span><span class="s">&quot;bar&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">comp</span><span class="p">&gt;</span> 
//子组件
this.$emit(&#39;update:myMessage&#39;,params);
</pre></div></li>
<li>带有 .sync 修饰符的 v-bind 不能和表达式一起使用,<code>v-bind:title.sync=”doc.title + ‘!’”</code>无效</li>
<li>v-bind.sync不能用于字面表达式 ，<code>v-bind.sync=”{ title: doc.title }”</code> 无效</li>
</ul>
</li>
<li>.prop</li>
<li>.camel: html不区分大小写,统一转换成小写，某些标签如svg只识别viewBox，无法识别 viewbox，使用.camel修饰符，能将其渲染为驼峰名。另外可以使用模板字符串来解决不区分大小写统一转换成小写的问题。</li>
</ul>
<h4 id="_82">参考链接<a class="headerlink" href="#_82" title="Permanent link"></a></h4>
<p><a href="https://segmentfault.com/a/1190000016786254" target="_blank">https://segmentfault.com/a/1190000016786254</a></p>
<h3 id="vue-data">vue data函数（为什么）<a class="headerlink" href="#vue-data" title="Permanent link"></a></h3>
<p>Vue组件中 data 为什么是一个函数？<br />
因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h2 id="2020723">2020/7/23<a class="headerlink" href="#2020723" title="Permanent link"></a></h2>
<h3 id="jsattributeproperty">js中的attribute和property<a class="headerlink" href="#jsattributeproperty" title="Permanent link"></a></h3>
<p>Attribute就是dom节点自带的属性，例如html中常用的id、class、title、align等<br />
Property是这个DOM元素作为对象，其附加的内容，例如childNodes、firstChild等<br />
<strong>attributes是属于property的一个子集</strong><br />
常用的Attribute，例如id、class、title等，已经被作为Property附加到DOM对象上，可以和Property一样取值和赋值。但是自定义的Attribute，不是property </p>
<ul>
<li>attribute取值、赋值：getAttribute()可以取得任何特性，不管是标准的还是自定义的。但是这个方法的浏览器兼容性有问题，有些浏览器可能会获取属性Property的值。因此jQuery要做一个测试，看getAttribute()是否是绝对获取特性Attribute的值
<div class="highlight"><pre><span class="nx">div1</span><span class="p">.</span><span class="nx">className</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">judge</span> <span class="o">=</span> <span class="nx">div1</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s2">&quot;className&quot;</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
</pre></div>
赋值：<code>div1.setAttribute('class', 'a')</code>; 取值：<code>var id = div1.getAttribute("id");</code></li>
<li>property取值、赋值：取值：<code>var id = div1.id;</code> 赋值：<code>div1.className = 'a';</code></li>
</ul>
<p><strong>对属性Property可以赋任何类型的值，而对特性Attribute只能赋值字符串</strong><br />
<strong>当更改Property或Attribute的其中一个的值时</strong>  </p>
<ul>
<li>property能够从attribute中得到同步；</li>
<li>attribute不会同步property上的值；</li>
<li>attribute和property之间的数据绑定是单向的，attribute-&gt;property；</li>
<li>更改property和attribute上的任意值，都会将更新反映到HTML页面中</li>
</ul>
<h4 id="_83">参考链接<a class="headerlink" href="#_83" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/lmjZone/p/8760232.html" target="_blank">https://www.cnblogs.com/lmjZone/p/8760232.html</a></p>
<h3 id="css">CSS选择器<a class="headerlink" href="#css" title="Permanent link"></a></h3>
<ul>
<li>元素选择器：又称为类型选择器（type selector），匹配文档语言元素类型的名称，如<code>p、h1、span</code>等</li>
<li>选择器分组：用“,”连接，如<code>h1, h2, h3, h4, h5, h6 {color:blue;}</code></li>
<li>类选择器</li>
<li>ID选择器：ID 选择器仅使用一次</li>
<li>属性选择器：如：<code>a[href][title] {color:red;}</code>。 可为 XML 文档使用属性选择器。可选择特定属性值的元素，如：<code>a[href="http://www.w3school.com.cn/about_us.asp"] {color: red;}</code></li>
<li>后代选择器： 如：<code>h1 em {color:red;}</code> 会匹配所有后代元素</li>
<li>子元素选择器：如：<code>h1 &gt; strong {color:red;}</code> 仅匹配子元素，孙子元素等后代元素不匹配</li>
<li>相邻兄弟选择器：选择紧接在另一元素后的元素，且二者有相同父元素，如：<code>h1 + p {margin-top:50px;}</code></li>
</ul>
<h4 id="css_1">CSS伪类<a class="headerlink" href="#css_1" title="Permanent link"></a></h4>
<p>写法： <code>:</code> 如：
<div class="highlight"><pre>a.red:visited {color: #FF0000}
<span class="p">&lt;</span><span class="nt">a</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;red&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;css_syntax.asp&quot;</span><span class="p">&gt;</span>CSS Syntax<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</pre></div></p>
<ul>
<li>:first-child 伪类:选择元素的第一个子元素,如<code>p:first-child {font-weight: bold;}</code>会匹配第一个出现的p元素</li>
<li>:lang 伪类：向带有指定 lang 属性的元素添加样式。如
<div class="highlight"><pre>q:lang(no) {
   quotes: &quot;~&quot; &quot;~&quot;
}
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>文字<span class="p">&lt;</span><span class="nt">q</span> <span class="na">lang</span><span class="o">=</span><span class="s">&quot;no&quot;</span><span class="p">&gt;</span>段落中的引用的文字<span class="p">&lt;/</span><span class="nt">q</span><span class="p">&gt;</span>文字<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
//文字~段落中的引用的文字~文字
</pre></div></li>
<li>:active 伪类：向被激活的元素添加样式。</li>
<li>:focus 伪类：向拥有键盘输入焦点的元素添加样式。</li>
<li>:hover 伪类：当鼠标悬浮在元素上方时，向元素添加样式。</li>
<li>:link 伪类：向未被访问的链接添加样式。</li>
<li>:visited 伪类：向已被访问的链接添加样式。</li>
</ul>
<h4 id="css_2">CSS伪元素<a class="headerlink" href="#css_2" title="Permanent link"></a></h4>
<ul>
<li>:first-line 伪元素：用文本的首行(<strong>第一行文本</strong>)设置特殊样式
<div class="highlight"><pre><span class="nt">p</span><span class="nd">:first-line</span> <span class="p">{</span>
    <span class="k">color</span><span class="o">:</span><span class="m">#ff0000</span><span class="p">;</span>
    <span class="k">font-variant</span><span class="o">:</span><span class="k">small-caps</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></li>
<li>:first-letter 伪元素：向文本的首字母设置特殊样式
<div class="highlight"><pre><span class="nt">p</span><span class="nd">:first-letter</span> <span class="p">{</span>
    <span class="k">color</span><span class="o">:</span><span class="m">#ff0000</span><span class="p">;</span>
    <span class="k">font-size</span><span class="o">:</span><span class="k">xx-large</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
&ldquo;first-letter&rdquo; 伪元素只能用于块级元素</li>
<li>CSS2-:before 伪元素：在元素的内容前面插入新内容<br />
如：在每个 <code>&lt;h1&gt;</code> 元素前面插入一幅图片
<div class="highlight"><pre><span class="nt">h1</span><span class="nd">:before</span> <span class="p">{</span>
    <span class="k">content</span><span class="o">:</span><span class="sx">url(logo.gif)</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></li>
<li>CSS2 - :after 伪元素：在元素的内容之后插入新内容。使用同before</li>
</ul>
<p>伪元素可以与 CSS 类配合使用:<br />
<div class="highlight"><pre><span class="nt">p</span><span class="nc">.article</span><span class="nd">:first-letter</span>
  <span class="p">{</span>
  <span class="k">color</span><span class="o">:</span> <span class="m">#FF0000</span><span class="p">;</span>
  <span class="p">}</span>
<span class="o">&lt;</span><span class="nt">p</span> <span class="nt">class</span><span class="o">=</span><span class="s2">&quot;article&quot;</span><span class="o">&gt;</span><span class="nt">This</span> <span class="nt">is</span> <span class="nt">a</span> <span class="nt">paragraph</span> <span class="nt">in</span> <span class="nt">an</span> <span class="nt">article</span><span class="err">。</span><span class="o">&lt;/</span><span class="nt">p</span><span class="o">&gt;</span>
</pre></div></p>
<h4 id="_84">参考链接<a class="headerlink" href="#_84" title="Permanent link"></a></h4>
<p><a href="https://www.w3school.com.cn/css/css_selector_type.asp" target="_blank">https://www.w3school.com.cn/css/css_selector_type.asp</a></p>
<h2 id="2020727">2020/7/27<a class="headerlink" href="#2020727" title="Permanent link"></a></h2>
<h3 id="es6-symbol">es6 Symbol<a class="headerlink" href="#es6-symbol" title="Permanent link"></a></h3>
<p>ES5中包含5种原始类型：字符串、数字、布尔值、null和undefined。ES6引入了第6种原始类型——Symbol<br />
ES5的对象属性名都是字符串，很容易造成属性名冲突。比如，使用了一个他人提供的对象，想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的，这样就从根本上 <strong>防止了对象属性名冲突</strong>。 这就是ES6引入Symbol的原因<br />
<em>注：Symbol函数前不能使用new命令，否则会报错。因为生成的 Symbol 是一个原始类型的值，不是对象</em>
<div class="highlight"><pre><span class="kd">let</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&quot;first name&quot;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">person</span><span class="p">[</span><span class="nx">firstName</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;huochai&quot;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;first name&quot;</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">[</span><span class="nx">firstName</span><span class="p">]);</span> <span class="c1">// &quot;huochai&quot;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">firstName</span><span class="p">);</span> <span class="c1">// &quot;Symbol(first name)&quot;</span>
</pre></div>
<em>注：Symbol 值作为对象属性名时，不能用点运算符</em></p>
<h4 id="symbol">共享Symbol<a class="headerlink" href="#symbol" title="Permanent link"></a></h4>
<p>ES6提供了一个可以随时访问的全局Symbol注册表：Symbol.for()
<div class="highlight"><pre><span class="kd">let</span> <span class="nx">uid</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s2">&quot;uid&quot;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">uid</span><span class="p">]</span><span class="o">:</span> <span class="s2">&quot;12345&quot;</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">object</span><span class="p">[</span><span class="nx">uid</span><span class="p">]);</span> <span class="c1">// &quot;12345&quot;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uid</span><span class="p">);</span> <span class="c1">// &quot;Symbol(uid)&quot;</span>
<span class="kd">let</span> <span class="nx">uid2</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s2">&quot;uid&quot;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uid</span> <span class="o">===</span> <span class="nx">uid2</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">object</span><span class="p">[</span><span class="nx">uid2</span><span class="p">]);</span> <span class="c1">// &quot;12345&quot;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uid2</span><span class="p">);</span> <span class="c1">// &quot;Symbol(uid)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">uid</span><span class="p">));</span> <span class="c1">// &quot;uid&quot;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">uid2</span><span class="p">));</span> <span class="c1">// &quot;uid&quot;</span>
<span class="kd">let</span> <span class="nx">uid3</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&quot;uid&quot;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">uid3</span><span class="p">));</span> <span class="c1">// undefined</span>
</pre></div>
Symbol.for()方法首先在全局Symbol注册表中搜索键为&rdquo;uid&rdquo;的Symbol是否存在。如果存在，直接返回已有的Symbol，否则，创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol<br />
可以使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的键</p>
<h4 id="_85">属性检索<a class="headerlink" href="#_85" title="Permanent link"></a></h4>
<p>Symbol作为属性名，该属性不会出现在for&hellip;in、for&hellip;of循环中，也不会被Object.getOwnPropertyNames()、Object.keys()、JSON.stringify()返回。于是，在ES6中添加了一个Object.getOwnpropertySymbols()方法来检索对象中的Symbol属性<br />
Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名<br />
由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法</p>
<h4 id="_86">参考链接<a class="headerlink" href="#_86" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/xiaohuochai/p/7245510.html" target="_blank">https://www.cnblogs.com/xiaohuochai/p/7245510.html</a></p>
<h2 id="2020729">2020/7/29<a class="headerlink" href="#2020729" title="Permanent link"></a></h2>
<h3 id="vueobjectdefinepropertyproxy">vue数据双向绑定：Object.defineProperty和Proxy<a class="headerlink" href="#vueobjectdefinepropertyproxy" title="Permanent link"></a></h3>
<p><strong>虽然Vue运用了数据劫持，但是依然离不开发布订阅的模式</strong><br />
Object.defineProperty：es5 、 vue2.0 在用<br />
Proxy： vue3.0, es6新特性  </p>
<blockquote>
<p>严格来讲Proxy应该被称为『代理』而非『劫持』</p>
</blockquote>
<p>实现一个完整的双向绑定需要以下几个要点: </p>
<ol>
<li>利用Proxy或Object.defineProperty生成的Observer（监听者）针对对象/对象的属性进行&rdquo;劫持&rdquo;,在属性发生变化后通知订阅者</li>
<li>Compile(解析器)解析模板中的Directive(指令)， 收集指令所依赖的方法和数据, 等待数据变化然后进行渲染</li>
<li>Watcher（订阅者）属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据 Compile提供的指令进行视图渲染,使得数据变化促使视图变化</li>
</ol>
<h4 id="objectdefineproperty">Object.defineProperty实现双向绑定<a class="headerlink" href="#objectdefineproperty" title="Permanent link"></a></h4>
<blockquote>
<p>Object.defineProperty()方法会直接在对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象</p>
</blockquote>
<p>Object.defineProperty的作用就是劫持一个对象的属性,通常对属性的getter和setter方法进行劫持,在对象的属性发生变化时进行特定的操作<br />
发布订阅模式实现双向绑定：</p>
<ol>
<li>先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它</li>
<li>实现监听者(Observer),用于监听属性值的变化</li>
<li>实现一个订阅者(Watcher)</li>
</ol>
<p>简陋版实现双向绑定（升级版还看不懂，是我太菜。。。）
<div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&quot;en&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&quot;UTF-8&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;viewport&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;width=device-width, initial-scale=1.0&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&quot;X-UA-Compatible&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;ie=edge&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>对象的数据双向绑定<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">id</span><span class="o">=</span><span class="s">&#39;input&#39;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="kd">let</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">)</span> <span class="c1">// 1. 获取输入框的dom节点</span>
    <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">// 2. 创建一个对象</span>
      <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;&quot;</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">oberseve</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 3. 对对象进行观察</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">obj</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="c1">// 3.1 判断参数是否为对象</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 3.2 对对象进行遍历，目的是为了把每个属性都设置get/set</span>
        <span class="nx">defineReactive</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span>
        <span class="nx">oberseve</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="c1">// 3.3 obj[key] 有可能还是一个函数，需要递归，给obj[key]里的属性进行设置get/set</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">defineReactive</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span> 
    <span class="c1">// 4. 使用Object.defineProperty</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">get</span><span class="p">()</span> <span class="p">{</span>
          <span class="nx">el</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span> <span class="c1">// 4.1 当读取时，把值赋值给input框</span>
          <span class="k">return</span> <span class="nx">value</span>
        <span class="p">},</span>
        <span class="nx">set</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">el</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">newVal</span> <span class="c1">// 4.1 当设置时，把赋值给input框</span>
          <span class="nx">value</span> <span class="o">=</span> <span class="nx">newVal</span>
        <span class="p">}</span>
      <span class="p">})</span>
    <span class="p">}</span>
    <span class="nx">oberseve</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// 5.执行该函数，对obj对象里的属性进行设置get/set</span>
    <span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// 6.给输入框绑定input事件</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="c1">// 7.当输入框输入内容时，我们会把输入框的</span>
                            <span class="c1">//   内容赋值给obj.name，触发obj.name的set方法</span>
    <span class="p">})</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>
缺点：</p>
<ul>
<li>无法监听数组变化。（数组下标直接赋值的方式无法监听变化）</li>
<li>只能劫持对象的属性：必须遍历对象的每个属性；必须深层遍历嵌套的对象</li>
</ul>
<h4 id="proxy">Proxy实现双向绑定<a class="headerlink" href="#proxy" title="Permanent link"></a></h4>
<p>Proxy可以直接监听对象而非属性;可以直接监听数组的变化
<div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&quot;en&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&quot;UTF-8&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;viewport&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;width=device-width, initial-scale=1.0&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&quot;X-UA-Compatible&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;ie=edge&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>对象的数据双向绑定<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">id</span><span class="o">=</span><span class="s">&#39;input&#39;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="kr">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="kr">const</span> <span class="nx">newObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">getting</span> <span class="nx">$</span><span class="p">{</span><span class="nx">key</span><span class="p">}</span><span class="o">!</span><span class="err">`</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
      <span class="p">},</span>
      <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="s1">&#39;text&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
          <span class="nx">p</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
      <span class="p">},</span>
    <span class="p">});</span>

    <span class="nx">input</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;keyup&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">newObj</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>
作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象，；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作<br />
要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作<br />
如果handler没有设置任何拦截，那就等同于直接通向原对象  </p>
<h5 id="reflect">reflect<a class="headerlink" href="#reflect" title="Permanent link"></a></h5>
<p>Reflect对象的设计目的:</p>
<ul>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上</li>
<li>修改某些Object方法的返回结果，让其变得更合理</li>
<li>让Object操作都变成函数行为</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为</li>
</ul>
<h4 id="proxy-objectdefineproperty">Proxy 与 Object.defineProperty 比较<a class="headerlink" href="#proxy-objectdefineproperty" title="Permanent link"></a></h4>
<ul>
<li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li>
<li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</li>
<li>Proxy的劣势就是兼容性问题，因此Vue的作者才声明需要等到3.0版本才能用Proxy重写</li>
</ul>
<h4 id="_87">参考链接<a class="headerlink" href="#_87" title="Permanent link"></a></h4>
<p><a href="https://blog.csdn.net/weixin_38641550/article/details/107484643" target="_blank">https://blog.csdn.net/weixin_38641550/article/details/107484643</a><br />
<a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf" target="_blank">https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf</a><br />
<a href="http://caibaojian.com/es6/proxy.html" target="_blank">http://caibaojian.com/es6/proxy.html</a></p>
<h2 id="2020730">2020/7/30<a class="headerlink" href="#2020730" title="Permanent link"></a></h2>
<h3 id="_88">浏览器的兼容性问题<a class="headerlink" href="#_88" title="Permanent link"></a></h3>
<ol>
<li>ie9 以下浏览器对 html5 新增标签不识别。<br />
解决：html5shiv.js
<div class="highlight"><pre><span class="c">&lt;!--[if lt IE 9]&gt;</span>
<span class="c">  &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span>
<span class="c">&lt;![endif]--&gt;</span>
</pre></div></li>
<li>IE9 以下浏览器不能使用 opacity（透明度） 
<div class="highlight"><pre><span class="nt">div</span>
<span class="p">{</span>
<span class="k">background-color</span><span class="o">:</span><span class="nb">red</span><span class="p">;</span>
<span class="k">opacity</span><span class="o">:</span><span class="m">0</span><span class="o">.</span><span class="m">5</span><span class="p">;</span>
<span class="n">filter</span><span class="o">:</span><span class="n">Alpha</span><span class="p">(</span><span class="k">opacity</span><span class="o">=</span><span class="m">50</span><span class="p">);</span> <span class="c">/* IE8 以及更早的浏览器 */</span>
<span class="p">}</span>
</pre></div></li>
<li>不同浏览器的标签默认的外补丁和内补丁不同（margin 和padding差异较大）<br />
解决：CSS文件开头<code>*{margin:0;padding:0;}</code>  使用通配符*来设置各个标签的内外补丁是0</li>
<li>字体大小定义不同。对字体大小small定义不同，Firefox为13px，而IE为16px，差别比较大<br />
解决：使用指定的字体大小如14px或者使用em</li>
<li></li>
</ol>
<h4 id="_89">参考链接<a class="headerlink" href="#_89" title="Permanent link"></a></h4>
<p><a href="https://juejin.im/post/59a3f2fe6fb9a0249471cbb4" target="_blank">https://juejin.im/post/59a3f2fe6fb9a0249471cbb4</a></p>
<h3 id="css-hack">css hack<a class="headerlink" href="#css-hack" title="Permanent link"></a></h3>
<p>不同浏览器对CSS的解析和认识不完全一样，因此会导致生成的页面效果不一样。需要针对不同的浏览器，去写不同CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中，也能得到想要的页面效果<br />
CSS Hack的目的，就是使CSS代码兼容不同的浏览器。当然，也可以反过来利用CSS Hack为不同版本的浏览器定制编写不同的CSS效果<br />
CSS Hack 大致有3种表现形式  </p>
<ul>
<li>属性前缀法（CSS类内部 Hack）<ul>
<li>比如IE6能识别下划线&rdquo;_&rdquo;和星号&rdquo;<em>&rdquo; ，IE7能识别星号&rdquo;</em>&ldquo;，但不能识别下划线,IE6-IE10都认识&rdquo;\9&rdquo;（<code>color:red\9</code>）,而Firefox这三个都不能认识。</li>
<li>对于书写顺序的关系，一般是将识别能力强的浏览器的CSS写在后边
<div class="highlight"><pre><span class="nt">div</span><span class="p">{</span>  
    <span class="k">background</span><span class="o">:</span><span class="nb">green</span><span class="p">;</span><span class="c">/*forfirefox*/</span>  
    <span class="o">*</span><span class="k">background</span><span class="o">:</span><span class="nb">red</span><span class="p">;</span><span class="c">/*forIE6 IE7*/</span>  
<span class="p">}</span>  
</pre></div></li>
</ul>
</li>
<li>选择器前缀法（选择器 Hack）<ul>
<li>IE6能识别*html .class{} , IE7能识别 +html .class{}或:first-child+html .class{},IE9能识别：root .class{}
<div class="highlight"><pre><span class="o">&lt;!</span><span class="nt">--</span> <span class="nt">针对ie9的hack</span> <span class="nt">--</span><span class="o">&gt;</span>
<span class="nd">:root</span> <span class="nc">.test</span>
<span class="p">{</span>
    <span class="k">background-color</span><span class="o">:</span><span class="nb">green</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></li>
</ul>
</li>
<li>IE条件注释法（HTML 头部引用 Hack), 针对所有IE（注：IE10+已经不再支持条件注释）<ul>
<li>HTML头部引用就比较特殊了，类似于程序语句，只能使用在HTML文件里，而不能在CSS文件中使用，并且 <strong>只有在IE浏览器下才能执行</strong>，在其他浏览器下面会被当做注释视而不见<br />
示例代码默认先调用css.css样式表
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text/css&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;css.css&quot;</span> <span class="p">/&gt;</span>
<span class="cp">&lt;!–[if IE 7]&gt;</span>
<span class="cp">&lt;!– 如果IE浏览器版是7,调用ie7.css样式表 –&gt;</span>
<span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text/css&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;ie7.css&quot;</span> <span class="p">/&gt;</span>
<span class="cp">&lt;![endif]–&gt;</span>
<span class="cp">&lt;!–[if lte IE 6]&gt;</span>
<span class="cp">&lt;!– 如果IE浏览器版本小于等于6,调用ie.css样式表 –&gt;</span>
<span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text/css&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;ie.css&quot;</span> <span class="p">/&gt;</span>
<span class="cp">&lt;![endif]–&gt;</span>
</pre></div>
注：
lte：就是Less than or equal to的简写，也就是小于或等于的意思。
lt ：就是Less than的简写，也就是小于的意思。
gte：就是Greater than or equal to的简写，也就是大于或等于的意思。
gt ：就是Greater than的简写，也就是大于的意思。
! ：就是不等于的意思，跟javascript里的不等于判断符相同。</li>
</ul>
</li>
</ul>
<p>下图显示各浏览器hack写法：<br />
属性值后面添加“!important”的写法只有IE6不能识别
<img alt="" src="/D:/study/upload/cd-knowledge-base/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/image/hack.png" /></p>
<h4 id="_90">参考链接<a class="headerlink" href="#_90" title="Permanent link"></a></h4>
<p><a href="https://www.jianshu.com/p/aeae0c575fe0" target="_blank">https://www.jianshu.com/p/aeae0c575fe0</a></p>
<h2 id="2020731">2020/7/31<a class="headerlink" href="#2020731" title="Permanent link"></a></h2>
<h3 id="html5">HTML5<a class="headerlink" href="#html5" title="Permanent link"></a></h3>
<p>&lt;!doctype&gt; 声明必须位于 HTML5 文档中的第一行(<em>通过&lt;!doctype&gt;标签，浏览器能够了解文档正在使用的HTML规范</em>)<br />
完全支持 CSS3</p>
<h4 id="_91">新特性<a class="headerlink" href="#_91" title="Permanent link"></a></h4>
<ul>
<li>用于绘画的 canvas 元素
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">c</span><span class="o">=</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;myCanvas&quot;</span><span class="p">);</span><span class="c1">//找到 &lt;canvas&gt; 元素:</span>
<span class="kd">var</span> <span class="nx">ctx</span><span class="o">=</span><span class="nx">c</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;2d&quot;</span><span class="p">);</span><span class="c1">//创建 context 对象</span>
</pre></div>
getContext(&ldquo;2d&rdquo;) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li>
<li>
<p>用于媒介回放的 video 和 audio 元素</p>
<ul>
<li>
<p>video
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">video</span> <span class="na">width</span><span class="o">=</span><span class="s">&quot;320&quot;</span> <span class="na">height</span><span class="o">=</span><span class="s">&quot;240&quot;</span> <span class="na">controls</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">source</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;movie.mp4&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;video/mp4&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">source</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;movie.ogg&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;video/ogg&quot;</span><span class="p">&gt;</span>
您的浏览器不支持Video标签。
<span class="p">&lt;/</span><span class="nt">video</span><span class="p">&gt;</span>
</pre></div></p>
</li>
<li>
<p>audio
<div class="highlight"><pre><span class="c">&lt;!-- control 属性供添加播放、暂停和音量控件 --&gt;</span>
<span class="p">&lt;</span><span class="nt">audio</span> <span class="na">controls</span><span class="p">&gt;</span>
<span class="c">&lt;!-- 使用第一个支持的source --&gt;</span>
  <span class="p">&lt;</span><span class="nt">source</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;horse.ogg&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;audio/ogg&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">source</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;horse.mp3&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;audio/mpeg&quot;</span><span class="p">&gt;</span>
您的浏览器不支持 audio 元素。
<span class="p">&lt;/</span><span class="nt">audio</span><span class="p">&gt;</span>
</pre></div></p>
</li>
<li>对本地离线存储的更好的支持</li>
<li>新的特殊内容元素，比如 article、footer、header、nav、section</li>
<li>新语义元素： <code>&lt;section&gt;, &lt;article&gt;, &lt;nav&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;aside&gt; 和 &lt;hgroup&gt;</code>  来创建更好的页面结构</li>
</ul>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;article&gt;</code></td>
<td>定义页面独立的内容区域。</td>
</tr>
<tr>
<td><code>&lt;aside&gt;</code></td>
<td>定义页面的侧边栏内容</td>
</tr>
<tr>
<td><code>&lt;details&gt;</code></td>
<td>用于描述文档或文档某个部分的细节</td>
</tr>
<tr>
<td><code>&lt;footer&gt;</code></td>
<td>定义 section 或 document 的页脚</td>
</tr>
<tr>
<td><code>&lt;header&gt;</code></td>
<td>定义了文档的头部区域</td>
</tr>
<tr>
<td><code>&lt;nav&gt;</code></td>
<td>定义导航链接的部分</td>
</tr>
<tr>
<td><code>&lt;section&gt;</code></td>
<td>定义文档中的节（section、区段)</td>
</tr>
<tr>
<td><code>&lt;wbr&gt;</code></td>
<td>规定在文本中的何处适合添加换行符</td>
</tr>
</tbody>
</table>
<ul>
<li>已移除元素：<code>&lt;font&gt;,&lt;frame&gt;,&lt;center&gt;</code></li>
<li>新表单元素：</li>
</ul>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;datalist&gt;</code></td>
<td>定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值</td>
</tr>
<tr>
<td><code>&lt;output&gt;</code></td>
<td>定义不同类型的输出，比如脚本的输出</td>
</tr>
</tbody>
</table>
</li>
</ul>
<div class="highlight"><pre>//detalist 使用实例
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">list</span><span class="o">=</span><span class="s">&quot;browsers&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;browser&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">datalist</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;browsers&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;Internet Explorer&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;Firefox&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;Chrome&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;Opera&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;Safari&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">datalist</span><span class="p">&gt;</span>

//output使用实例
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;range&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;a&quot;</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;50&quot;</span><span class="p">&gt;</span>100
+<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;number&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;b&quot;</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;50&quot;</span><span class="p">&gt;</span>
=<span class="p">&lt;</span><span class="nt">output</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;x&quot;</span> <span class="na">for</span><span class="o">=</span><span class="s">&quot;a b&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">output</span><span class="p">&gt;</span>
</pre></div>

<ul>
<li>新的表单控件，比如 calendar、date、time、email、url、search</li>
</ul>
<h4 id="_92">元素变动<a class="headerlink" href="#_92" title="Permanent link"></a></h4>
<h4 id="_93">参考链接<a class="headerlink" href="#_93" title="Permanent link"></a></h4>
<p><a href="https://www.w3cschool.cn/html5/html5-new-element.html" target="_blank">https://www.w3cschool.cn/html5/html5-new-element.html</a><br />
<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5</a></p>
<h2 id="202083">2020/8/3<a class="headerlink" href="#202083" title="Permanent link"></a></h2>
<h3 id="babel">Babel转码器<a class="headerlink" href="#babel" title="Permanent link"></a></h3>
<p>ECMAScript 6(ES6)的发展速度非常之快，但现代浏览器对ES6新特性支持度不高，所以要想在浏览器中直接使用ES6的新特性就得借助别的工具来实现<br />
Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行
<div class="highlight"><pre><span class="c1">// 转码前</span>
<span class="nx">input</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">// 转码后</span>
<span class="nx">input</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
上面的原始代码用了箭头函数，这个特性还没有得到广泛支持，Babel将其转为普通函数，就能在现有的JavaScript环境执行了</p>
<h4 id="babel-polyfill">babel-polyfill<a class="headerlink" href="#babel-polyfill" title="Permanent link"></a></h4>
<p>Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。<br />
举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片</p>
<h2 id="2020812">2020/8/12<a class="headerlink" href="#2020812" title="Permanent link"></a></h2>
<h3 id="js">JS事件的浏览器兼容处理<a class="headerlink" href="#js" title="Permanent link"></a></h3>
<ul>
<li>event事件问题
<div class="highlight"><pre><span class="nb">document</span><span class="p">.</span><span class="nx">onclick</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span><span class="c1">//兼容写法；</span>
    <span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="nx">e</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">event</span><span class="p">;</span>
    <span class="c1">//火狐只支持传值方法，不支持window.event</span>
    <span class="c1">//ie9以上两者兼容，ie9以下只支持window.event</span>
<span class="p">}</span>
</pre></div></li>
<li>监听事件
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">addEvent</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">type</span><span class="p">,</span><span class="nx">fn</span><span class="p">){</span><span class="c1">//添加事件监听，三个参数分别为 对象、事件类型、事件处理函数，默认为false</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span><span class="nx">fn</span><span class="p">,</span><span class="kc">false</span><span class="p">);</span><span class="c1">//非IE</span>
    <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="o">+</span><span class="nx">type</span><span class="p">,</span><span class="nx">fn</span><span class="p">);</span><span class="c1">//ie,这里已经加上on，传参的时候注意不要重复加了</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">removeEvent</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">type</span><span class="p">,</span><span class="nx">fn</span><span class="p">){</span><span class="c1">//删除事件监听</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span><span class="nx">fn</span><span class="p">,</span><span class="kc">false</span><span class="p">);</span><span class="c1">//非IE</span>
    <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">detachEvent</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="o">+</span><span class="nx">type</span><span class="p">,</span><span class="nx">fn</span><span class="p">);</span><span class="c1">//ie，这里已经加上on，传参的时候注意不要重复加了</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div></li>
<li>阻止默认事件
<div class="highlight"><pre><span class="nb">document</span><span class="p">.</span><span class="nx">onclick</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">e</span><span class="o">=</span><span class="nx">e</span><span class="o">||</span><span class="nb">window</span><span class="p">.</span><span class="nx">event</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span><span class="c1">//W3C标准</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
      <span class="nx">e</span><span class="p">.</span><span class="nx">returnValue</span><span class="o">=</span><span class="s1">&#39;false&#39;</span><span class="p">;</span><span class="c1">//IE..</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></li>
<li>鼠标滚轮滚动事件
<div class="highlight"><pre><span class="c1">//火狐中的滚轮事件</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;DOMMouseScroll&quot;</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">detail</span><span class="p">);</span><span class="c1">//若前滚的话为 -3，后滚的话为 3</span>
<span class="p">},</span><span class="kc">false</span><span class="p">)</span>
<span class="c1">//非火狐中的滚轮事件</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">onmousewheel</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">detail</span><span class="p">);</span><span class="c1">//前滚：120，后滚：-120</span>
<span class="p">}</span>
</pre></div></li>
</ul>
<h2 id="2021129">2021/1/29<a class="headerlink" href="#2021129" title="Permanent link"></a></h2>
<h3 id="imagejpegcontent-type-imagegif">后台返回 image/jpeg（content-type: image/gif）类型数据，怎么展示图片<a class="headerlink" href="#imagejpegcontent-type-imagegif" title="Permanent link"></a></h3>
<ul>
<li>请求加上配置 （必须）
<code>responseType: 'arraybuffer',</code></li>
<li>得到的后台数据resData转base64
<div class="highlight"><pre> var base64 = btoa( new Uint8Array(resData) .reduce((data, byte) =&gt; data + String.fromCharCode(byte), &#39;&#39;));
 this.ImgSrc=&#39;data:image/png;base64,&#39; + base64 ;
</pre></div></li>
<li>小程序中，需要用小程序的方法转：<br />
<div class="highlight"><pre>var base64 = wx.arrayBufferToBase64(resData);
this.ImgSrc = &#39;data:image/png;base64,&#39; + base64 
</pre></div></li>
</ul>
<h4 id="_94">参考链接<a class="headerlink" href="#_94" title="Permanent link"></a></h4>
<p><a href="https://blog.csdn.net/github_38928905/article/details/107554306" target="_blank">https://blog.csdn.net/github_38928905/article/details/107554306</a>  </p>
<h2 id="202124">2021/2/4<a class="headerlink" href="#202124" title="Permanent link"></a></h2>
<h3 id="callapplaybind">call,applay,bind<a class="headerlink" href="#callapplaybind" title="Permanent link"></a></h3>
<h4 id="call-applay">call &amp; applay<a class="headerlink" href="#call-applay" title="Permanent link"></a></h4>
<p>当函数通过Function对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的this值可绑定到 call() &amp; apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它<br />
事实上apply 和 call 的用法几乎相同, 唯一的差别在于：当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span><span class="mi">3</span><span class="p">};</span>
<span class="nx">add</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span> <span class="c1">// 1 + 3 + 5 + 7 = 16</span>
<span class="nx">add</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]);</span> <span class="c1">// 1 + 3 + 10 + 20 = 34</span>

<span class="kd">function</span> <span class="nx">tt</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 返回对象见下图（图1）</span>
<span class="nx">tt</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">// Number {[[PrimitiveValue]]: 5} </span>
<span class="nx">tt</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="s1">&#39;asd&#39;</span><span class="p">);</span> <span class="c1">// String {0: &quot;a&quot;, 1: &quot;s&quot;, 2: &quot;d&quot;, length: 3, [[PrimitiveValue]]: &quot;asd&quot;}</span>
</pre></div></p>
<h4 id="bind">bind<a class="headerlink" href="#bind" title="Permanent link"></a></h4>
<p>和call很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数以及bind接收的参数列表的使用<br />
有时候可用bind实现函数珂里化（？）
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Dot&#39;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">printName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">dot</span> <span class="o">=</span> <span class="nx">printName</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">dot</span><span class="p">)</span> <span class="c1">// function () { … }</span>
<span class="nx">dot</span><span class="p">()</span>  <span class="c1">// Dot</span>
</pre></div></p>
<div class="highlight"><pre><span class="c1">//参数的使用</span>
<span class="kd">function</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">fn1</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;Dot&#39;</span><span class="p">);</span>

<span class="nx">fn</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">);</span>            <span class="c1">// A B C</span>
<span class="nx">fn1</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">);</span>           <span class="c1">// Dot A B</span>
<span class="nx">fn1</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">);</span>                <span class="c1">// Dot B C</span>
<span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;Dot&#39;</span><span class="p">);</span>      <span class="c1">// Dot undefined undefined</span>
</pre></div>

<h4 id="_95">参考链接<a class="headerlink" href="#_95" title="Permanent link"></a></h4>
<p><a href="https://www.jianshu.com/p/bc541afad6ee" target="_blank">https://www.jianshu.com/p/bc541afad6ee</a><br />
<a href="https://www.cnblogs.com/dongcanliang/p/7054176.html" target="_blank">https://www.cnblogs.com/dongcanliang/p/7054176.html</a>  </p>
<h2 id="2021223">2021/2/23<a class="headerlink" href="#2021223" title="Permanent link"></a></h2>
<h3 id="flex">flex布局<a class="headerlink" href="#flex" title="Permanent link"></a></h3>
<h4 id="flex_1">flex布局是什么<a class="headerlink" href="#flex_1" title="Permanent link"></a></h4>
<p>Flex 是 Flexible Box 的缩写，意为&rdquo;弹性布局&rdquo;，用来为盒状模型提供最大的灵活性。<br />
设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。  </p>
<h4 id="_96">容器属性<a class="headerlink" href="#_96" title="Permanent link"></a></h4>
<ul>
<li>flex-direction：决定主轴的方向（即项目的排列方向：横轴/纵轴排列）  <ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
</li>
<li>flex-wrap：属性定义，如果一条轴线排不下，如何换行<ul>
<li>nowrap | wrap | wrap-reverse： 不换行|换行（第一行在上面）|换行（第一行在下面）;</li>
</ul>
</li>
<li>flex-flow：是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>
<li>justify-content：定义了项目在主轴上的对齐方式<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
</li>
<li>align-items： 定义项目在交叉轴上如何对齐<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</li>
<li>align-content：多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴</li>
</ul>
</li>
</ul>
<h4 id="_97">项目属性<a class="headerlink" href="#_97" title="Permanent link"></a></h4>
<ul>
<li>order：定义项目的排列顺序。数值越小，排列越靠前，默认为0  </li>
<li>flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</li>
<li>flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</li>
<li>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间</li>
<li>flex：是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li>
<li>align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
<h4 id="_98">参考链接<a class="headerlink" href="#_98" title="Permanent link"></a></h4>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a>  </p>
<h3 id="bfc">BFC(块级格式化上下文)<a class="headerlink" href="#bfc" title="Permanent link"></a></h3>
<p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等.<br />
display 属性为 block, list-item, table 的元素，会产生BFC<br />
给这些元素添加如下属性就可以触发BFC。</p>
<ul>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible。</li>
</ul>
<h4 id="bfc_1">BFC布局规则特性<a class="headerlink" href="#bfc_1" title="Permanent link"></a></h4>
<ul>
<li>在BFC中，盒子从顶端开始垂直地一个接一个地排列</li>
<li>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</li>
<li>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）</li>
</ul>
<h4 id="bfc_2">BFC的主要用途<a class="headerlink" href="#bfc_2" title="Permanent link"></a></h4>
<ol>
<li>清除元素内部浮动:只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了</li>
<li>解决外边距合并问题</li>
</ol>
<h4 id="_99">参考链接<a class="headerlink" href="#_99" title="Permanent link"></a></h4>
<p><a href="https://www.jianshu.com/p/498145565e4f" target="_blank">https://www.jianshu.com/p/498145565e4f</a>  </p>
<h3 id="_100">前端鉴权<a class="headerlink" href="#_100" title="Permanent link"></a></h3>
<h4 id="_101">常见的几种鉴权方式：<a class="headerlink" href="#_101" title="Permanent link"></a></h4>
<h5 id="http-basic-authentication">HTTP Basic Authentication<a class="headerlink" href="#http-basic-authentication" title="Permanent link"></a></h5>
<p>是HTTP中最为简单的认证方式，因为简单，所以不是很安全。<br />
这种授权方式是浏览器遵守http协议实现的基本授权方式,HTTP协议进行通信的过程中，HTTP协议定义了基本认证认证允许HTTP服务器对客户端进行用户身份证的方法。<br />
当一个客户端向一个需要认证的HTTP服务器进行数据请求时，如果之前没有认证过，HTTP服务器会返回401状态码，要求客户端输入用户名和密码，用户输入用户名和密码后，用户名和密码会经过BASE64加密附加到请求信息中再次请求HTTP服务器，HTTP服务器会根据请求头携带的认证信息，决定是否认证成功及做出相应的响应。</p>
<h5 id="session-cookie">session-cookie<a class="headerlink" href="#session-cookie" title="Permanent link"></a></h5>
<p>(这种方式在老的系统较为常见，只适用于web系统，以前用 java servlet 写服务端时候，都会自动维护session，会在cookie写一个JSESSIONID的值)<br />
这种方式是利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证，即session和cookie配合使用，由于http请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话，将同一个客户端的请求都维护在各自的会话中，每当请求到达服务器端的时候，先检查改客户端有没有在服务端创建session,如果有则已经认证成功了，否则就认证失败</p>
<h5 id="token_1">Token 验证<a class="headerlink" href="#token_1" title="Permanent link"></a></h5>
<p>(具体可见上文  <strong>cookie、session、token（令牌）</strong> )<br />
Token验证的特点：  </p>
<ul>
<li>无状态，可扩展</li>
<li>支持多设备</li>
<li>跨程序调用</li>
<li>安全</li>
</ul>
<h5 id="oauth">OAuth(开放授权)<a class="headerlink" href="#oauth" title="Permanent link"></a></h5>
<p>是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供OAuth认证服务的厂商有支付宝，QQ,微信</p>
<h4 id="vue_4">vue项目前端鉴权方式常用的有以下三种：<a class="headerlink" href="#vue_4" title="Permanent link"></a></h4>
<ol>
<li>渲染菜单时控制模块按钮的显示隐藏（不足：直接输入链接仍然可以访问模块）</li>
<li>在路由导航守卫中拦截，针对没有权限的模块进行重定向（不足：每次访问模块都需要鉴定权限，模块数量过多时会影响系统性能）</li>
<li>借助vue-router 2.x版本新加的API addRouters动态添加路由信息（不足：首次加载需要解析和添加，多跳转一次路由）</li>
<li>
<p>优化的方案：addRoutes动态添加，首屏加载时间可能会多出0.5s左右，加载一次之后后续就不需要再进行处理，可以提升系统的可靠性与稳定性  </p>
<ul>
<li>定义固定路由，用于路由初始化，如：登录页、404页面等</li>
<li>路由导航守卫前置拦截。为了方便，将路由权限信息保存到vuex中，在路由跳转时，判断state中是否存在menu信息，如果不存在，则向后端请求权限信息，此部分需要阻塞页面的跳转，改为同步执行</li>
<li>
<p>注意事项：</p>
<ul>
<li>由于路由时动态添加的，存储在内存中，页面刷新之后内存中变量也会消失，动态添加的路由也会随之消失，所以每次刷新页面需要重新走一遍添加路由的流程。</li>
<li>由于路由是动态添加的，在路由跳转时，添加的路由并没有生效，所以还需要多跳转一次页面</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="_102">按钮鉴权<a class="headerlink" href="#_102" title="Permanent link"></a></h4>
<p>可以通过自定义指令，动态传入条件参数来实现按钮的显示隐藏</p>
<h4 id="_103">参考链接<a class="headerlink" href="#_103" title="Permanent link"></a></h4>
<p><a href="https://blog.csdn.net/ywl570717586/article/details/88241445" target="_blank">https://blog.csdn.net/ywl570717586/article/details/88241445</a><br />
<a href="https://juejin.cn/post/6844903688994029582" target="_blank">https://juejin.cn/post/6844903688994029582</a><br />
<a href="https://www.cnblogs.com/gerry2019/p/11045555.html" target="_blank">https://www.cnblogs.com/gerry2019/p/11045555.html</a>  </p>
<h2 id="2021224">2021/2/24<a class="headerlink" href="#2021224" title="Permanent link"></a></h2>
<h3 id="domcontentloaded-load">DOMContentLoaded 与 load事件<a class="headerlink" href="#domcontentloaded-load" title="Permanent link"></a></h3>
<h4 id="domcontentloaded">DOMContentLoaded<a class="headerlink" href="#domcontentloaded" title="Permanent link"></a></h4>
<blockquote>
<p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载</p>
</blockquote>
<p>当输入一个URL，页面的展示首先是空白的，然后过一会，页面会展示出内容，但是页面的有些资源比如说图片资源还无法看到，此时页面是可以正常的交互，过一段时间后，图片才完成显示在页面。从页面空白到展示出页面内容，会触发DOMContentLoaded事件。而这段时间就是HTML文档被加载和解析完成。<br />
在解析html的过程中，html的解析会被中断，这是因为javascript会阻塞dom的解析。当解析过程中遇到 <code>&lt;script&gt;</code> 标签的时候，便会停止解析过程，转而去处理脚本，如果脚本是内联的,浏览器会先去执行这段内联的脚本，如果是外链的，那么先会去加载脚本，然后执行。在处理完脚本之后，浏览器便继续解析HTML文档。<br />
在现代浏览器中，为了减缓渲染被阻塞的情况，现代的浏览器都使用了 <strong>猜测预加载</strong> 。当解析被阻塞的时候，浏览器会有一个轻量级的HTML（或CSS）扫描器（scanner）继续在文档中扫描，查找那些将来可能能够用到的资源文件的url，在渲染器使用它们之前将其下载下来。<br />
当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件；如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等位于脚本前面的css加载完才能执行。<strong>在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。</strong></p>
<h4 id="load">load<a class="headerlink" href="#load" title="Permanent link"></a></h4>
<blockquote>
<p>当一个资源及其依赖资源已完成加载时，将触发load事件</p>
</blockquote>
<p>页面上所有的资源（图片，音频，视频等）被加载以后才会触发load事件，简单来说，页面的load事件会在DOMContentLoaded被触发之后才触发。<br />
在 jQuery 中经常使用的<code>$(document).ready(function() { // ...代码... })</code>; 其实监听的就是 DOMContentLoaded 事件，而 <code>$(document).load(function() { // ...代码... })</code>; 监听的是 load 事件。在用jquery的时候，我们一般都会将函数调用写在ready方法内，就是页面被解析后，我们就可以访问整个页面的所有dom元素，可以缩短页面的可交互时间，提高整个页面的体验。</p>
<h4 id="cssjs">为什么一再强调将css放在头部，将js文件放在尾部？<a class="headerlink" href="#cssjs" title="Permanent link"></a></h4>
<p>是因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。<br />
那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。<br />
其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。</p>
<h4 id="_104">参考链接<a class="headerlink" href="#_104" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/caizhenbo/p/6679478.html" target="_blank">https://www.cnblogs.com/caizhenbo/p/6679478.html</a><br />
<a href="https://blog.csdn.net/liubangbo/article/details/86298859" target="_blank">https://blog.csdn.net/liubangbo/article/details/86298859</a>  </p>
<h3 id="vuevue-lazyload">vue图片懒加载（vue-lazyload）<a class="headerlink" href="#vuevue-lazyload" title="Permanent link"></a></h3>
<p>先将img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储在img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。<br />
这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题</p>
<h4 id="_105">可优化内容<a class="headerlink" href="#_105" title="Permanent link"></a></h4>
<ul>
<li><strong>滚动函数的节流</strong>：当用户在快速滚动页面时，不会加载图片资源，只有当用户停下或是逐渐放缓下滑速度时（即两次滚动的时间间隔超过阈值之后），才加载图片资源</li>
<li><strong>预加载</strong>：预加载就是指预先加载一些未在当前视窗内，但是即将出现的一些图片。即：加载当前屏幕的上一屏和下一屏的图片资源</li>
<li><strong>知乎网站的优化方案</strong>：先加载低质量的小图，再加载清晰的高质量原图</li>
</ul>
<h4 id="_106">参考链接<a class="headerlink" href="#_106" title="Permanent link"></a></h4>
<p><a href="https://mp.weixin.qq.com/s/Syqoz_Hkh7JY4GYIu_TE3A" target="_blank">https://mp.weixin.qq.com/s/Syqoz_Hkh7JY4GYIu_TE3A</a><br />
<a href="https://blog.csdn.net/Sunshine0508/article/details/97892311" target="_blank">https://blog.csdn.net/Sunshine0508/article/details/97892311</a></p>
<h3 id="vue3">vue项目实现路由按需加载(路由懒加载)的3种方式<a class="headerlink" href="#vue3" title="Permanent link"></a></h3>
<p>像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出现长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。</p>
<h4 id="_107">异步加载<a class="headerlink" href="#_107" title="Permanent link"></a></h4>
<div class="highlight"><pre><span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/home&#39;</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;home&#39;</span><span class="p">,</span> <span class="nx">component</span><span class="o">:</span> <span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="nx">require</span><span class="p">([</span><span class="s1">&#39;@/components/home&#39;</span><span class="p">],</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">},</span>
</pre></div>

<h4 id="import">路由懒加载(使用import)<a class="headerlink" href="#import" title="Permanent link"></a></h4>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">Home</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;@/components/home&#39;</span><span class="p">)</span>
</pre></div>

<h4 id="webpackrequireensure">webpack提供的require.ensure()<a class="headerlink" href="#webpackrequireensure" title="Permanent link"></a></h4>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">require</span><span class="p">.</span><span class="nx">ensure</span><span class="p">([],</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;../components/list/list&#39;</span><span class="p">)),</span> <span class="s1">&#39;list&#39;</span><span class="p">);</span>
<span class="c1">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span>
<span class="kr">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Router</span><span class="p">({</span>
    <span class="nx">routes</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span>
           <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/list/blog&#39;</span><span class="p">,</span>
           <span class="nx">component</span><span class="o">:</span> <span class="nx">list</span><span class="p">,</span>
           <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;blog&#39;</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">})</span>
</pre></div>

<h4 id="_108">参考链接<a class="headerlink" href="#_108" title="Permanent link"></a></h4>
<p><a href="https://blog.csdn.net/xm1037782843/article/details/88225104?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=05d4c1f7-07a7-40c3-a2d3-e91c97187e0e&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control" target="_blank">https://blog.csdn.net/xm1037782843/article/details/88225104?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=05d4c1f7-07a7-40c3-a2d3-e91c97187e0e&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control</a></p>
<h2 id="2021225">2021/2/25<a class="headerlink" href="#2021225" title="Permanent link"></a></h2>
<h3 id="event-loop">event loop(事件循环)<a class="headerlink" href="#event-loop" title="Permanent link"></a></h3>
<p>javascript从诞生之日起就是一门 <strong>单线程</strong> 的 <strong>非阻塞</strong> 的脚本语言。这是由其最初的用途来决定的：与浏览器交互。<br />
javascript引擎 利用 event loop 实现了非阻塞</p>
<h4 id="_109">执行栈与事件队列<a class="headerlink" href="#_109" title="Permanent link"></a></h4>
<p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针<br />
当调用一个方法的时候，js会生成一个与这个方法对应的 <strong>执行环境（context）</strong>，又叫 <strong>执行上下文</strong>。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为 <strong>执行栈</strong><br />
当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕<br />
js引擎遇到一个 <strong>异步事件</strong> 后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为 <strong>事件队列</strong>。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码&hellip;，如此反复，这样就形成了一个无限的循环。这就是 <strong>事件循环（Event Loop）</strong> 。</p>
<h4 id="micro-taskmacro-task">微任务（micro task）和宏任务（macro task）<a class="headerlink" href="#micro-taskmacro-task" title="Permanent link"></a></h4>
<p>以下事件属于宏任务：</p>
<ul>
<li>setInterval()</li>
<li>setTimeout()</li>
</ul>
<p>以下事件属于微任务：</p>
<ul>
<li>new Promise()</li>
<li>new MutaionObserver()</li>
</ul>
<p>在一个事件循环中，异步事件返回结果后会被放到一个 <strong>事件队列</strong> 中。然后，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈&hellip;如此反复，进入循环。</p>
<p><strong>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>  </p>
<div class="highlight"><pre><span class="c1">//示例</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
<span class="p">})</span>
<span class="c1">//输出结果为：</span>
<span class="c1">//2</span>
<span class="c1">//3</span>
<span class="c1">//1</span>
</pre></div>

<div class="highlight"><pre><span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise1&#39;</span><span class="p">)</span>  
  <span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout2&#39;</span><span class="p">)</span>
  <span class="p">},</span><span class="mi">0</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout1&#39;</span><span class="p">)</span>
  <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise2&#39;</span><span class="p">)</span>    
  <span class="p">})</span>
<span class="p">},</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">//输出结果为</span>
<span class="c1">//Promise1，setTimeout1，Promise2，setTimeout2</span>
</pre></div>

<h4 id="node-event-loop">Node与浏览器的 Event Loop 差异<a class="headerlink" href="#node-event-loop" title="Permanent link"></a></h4>
<p>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">test</span> <span class="p">()</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">)</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;children2&#39;</span><span class="p">)</span>
        <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;children2-1&#39;</span><span class="p">)})</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;children3&#39;</span><span class="p">)</span>
        <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;children3-1&#39;</span><span class="p">)})</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;children1&#39;</span><span class="p">)})</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">)</span> 
<span class="p">}</span>

<span class="nx">test</span><span class="p">()</span>

<span class="c1">// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)</span>
<span class="c1">// start</span>
<span class="c1">// end</span>
<span class="c1">// children1</span>
<span class="c1">// children2</span>
<span class="c1">// children3</span>
<span class="c1">// children2-1</span>
<span class="c1">// children3-1</span>

<span class="c1">// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)</span>
<span class="c1">// start</span>
<span class="c1">// end</span>
<span class="c1">// children1</span>
<span class="c1">// children2</span>
<span class="c1">// children2-1</span>
<span class="c1">// children3</span>
<span class="c1">// children3-1</span>
</pre></div></p>
<h4 id="_110">参考链接<a class="headerlink" href="#_110" title="Permanent link"></a></h4>
<p><a href="https://juejin.cn/post/6844903761949753352" target="_blank">https://juejin.cn/post/6844903761949753352</a><br />
<a href="https://www.cnblogs.com/cangqinglang/p/8967268.html" target="_blank">https://www.cnblogs.com/cangqinglang/p/8967268.html</a></p>
<h2 id="2021311">2021/3/11(中联重科)<a class="headerlink" href="#2021311" title="Permanent link"></a></h2>
<h3 id="promise">promise<a class="headerlink" href="#promise" title="Permanent link"></a></h3>
<p>Promise的三种状态 <strong>pending、fulfilled、rejected(未决定，履行，拒绝)</strong><br />
同一时间只能存在一种状态，且状态一旦改变就不能再变。promise是一个构造函数，promise对象代表一项有两种可能结果（成功或失败）的任务，它还持有多个回调，出现不同结果时分别发出相应回调。<br />
1. 初始化，状态：pending
2. 当调用resolve(成功)，状态：pengding=&gt;fulfilled
3. 当调用reject(失败)，状态：pending=&gt;rejected</p>
<h3 id="keep-alive">keep-alive<a class="headerlink" href="#keep-alive" title="Permanent link"></a></h3>
<p>keep-alive作用：对组件进行缓存，提高性能<br />
有两个组件A、B。我们在A组件上操作的数据，此时我们切换到组件B，再切换到A组件，A组件并不会重新渲染，而是保存之前的状态。<br />
keep-alive是一个抽象标签，不会被渲染承具体的dom元素。这点与template类似。</p>
<h4 id="props">Props<a class="headerlink" href="#props" title="Permanent link"></a></h4>
<ul>
<li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li>max - 数字。最多可以缓存多少组件实例。</li>
</ul>
<h4 id="activateddeactivated">钩子函数（activated，deactivated）<a class="headerlink" href="#activateddeactivated" title="Permanent link"></a></h4>
<p>页面第一次进入，钩子的触发顺序created-&gt; mounted-&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。<br />
<strong>activated</strong>：包含了keep-alive的组件，created()、mounted()都只会触发一次。但是activated每一次进入组件，都会触发一次</p>
<h3 id="ononceoffemit">$on,$once,$off,$emit<a class="headerlink" href="#ononceoffemit" title="Permanent link"></a></h3>
<h4 id="onoffemit">$on,$off,$emit<a class="headerlink" href="#onoffemit" title="Permanent link"></a></h4>
<ul>
<li>$on:监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数</li>
<li>$off:移除自定义事件监听器.如果没有提供参数，则移除所有的事件监听器</li>
<li>$emit :触发当前实例上的事件。附加参数都会传给监听器回调</li>
</ul>
<h4 id="once">$once<a class="headerlink" href="#once" title="Permanent link"></a></h4>
<p>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。<br />
可以使用$once(‘hook:beforeDestory’,() =&gt; {})清理定时器<br />
在vue项目清理定时器，通常有两种方法  </p>
<ul>
<li>生命周期函数（beforeDestroy()）中销毁定时器：<br />
  缺点： <ol>
<li>vue实例中需要有这个定时器的实例，感觉有点多余;</li>
<li>创建的定时器代码和销毁定时器的代码没有放在一起，通常很容易忘记去清理这个定时器，不容易维护;</li>
</ol>
</li>
<li>直接在需要定时器的方法或者生命周期函数中声明并销毁（$once）
<div class="highlight"><pre><span class="kr">export</span> <span class="k">default</span><span class="p">{</span>
  <span class="nx">methods</span><span class="o">:</span><span class="p">{</span>
    <span class="nx">fun1</span><span class="p">(){</span>
      <span class="kr">const</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
        <span class="c1">//具体执行代码</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">);</span>
      <span class="p">},</span><span class="mi">1000</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$once</span><span class="p">(</span><span class="s1">&#39;hook:beforeDestory&#39;</span><span class="p">,()</span><span class="o">=&gt;</span><span class="p">{</span>
        <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
        <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></li>
</ul>
<h3 id="vue2vue3">vue2,vue3的区别<a class="headerlink" href="#vue2vue3" title="Permanent link"></a></h3>
<ul>
<li>移除过滤器filters</li>
<li>生命周期的变化  <ul>
<li>移除了beforeCreate（）和Created（）</li>
<li>新增了setup()（代替beforeCreate（）和Created（））.</li>
<li>在剩余六个函数之前加入了on（onMounted,onBeforeMount&hellip;）  </li>
</ul>
</li>
<li>key的变化:vue3 中 v-if/v-else/v-else-if ， key不再是必须填写的了，新版的vue会自动生成唯一的key，但是如果自己手动传入了key，这个值必须是唯一的，不能使用重复的值</li>
<li>Vue 3 的 Template 支持多个根标签，Vue 2 不支持、</li>
</ul>
<h2 id="2020316">2020/3/16<a class="headerlink" href="#2020316" title="Permanent link"></a></h2>
<h3 id="js_1">js数据类型判断<a class="headerlink" href="#js_1" title="Permanent link"></a></h3>
<p>js数据分为两种类型：原始数据类型和引用数据类型。<br />
原始数据类型有：string、number、boolean、undefined和null<br />
引用数据类型有：Function、Object、Date、RegExp、Number、String、Boolean和自定义类等  </p>
<p>其中原始数据类型也称基础数据类型，是不可拆分的数据类型，他存在于 <strong>栈</strong> 中；而引用数据类型也是通常意义上所说的类，存在于 <strong>堆</strong> 中。</p>
<h4 id="typeof">typeof<a class="headerlink" href="#typeof" title="Permanent link"></a></h4>
<p>对于原始数据类型，我们可以使用typeof()函数来判断他的数据类型</p>
<h4 id="instanceof">instanceof<a class="headerlink" href="#instanceof" title="Permanent link"></a></h4>
<p>typeof()函数不能用来判断引用数据类型。instanceof可以用来判断一个变量是否是某个对象的实例，可以用于引用数据类型判断</p>
<h4 id="objectprototypetostringcall">Object.prototype.toString.call()<a class="headerlink" href="#objectprototypetostringcall" title="Permanent link"></a></h4>
<p>可以通用的来判断原始数据类型和引用数据类型。但无法判断自定义类
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">num1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">num2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">num1</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;[object Number]&quot;</span><span class="p">;</span>      <span class="c1">//true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">num2</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;[object Number]&quot;</span><span class="p">;</span>      <span class="c1">//true</span>
</pre></div></p>
<h4 id="_111">参考链接<a class="headerlink" href="#_111" title="Permanent link"></a></h4>
<p><a href="https://www.cnblogs.com/leejersey/p/5191924.html" target="_blank">https://www.cnblogs.com/leejersey/p/5191924.html</a></p>
<h3 id="_112">日常问题（长期更新）<a class="headerlink" href="#_112" title="Permanent link"></a></h3>
<h4 id="_113">常见<a class="headerlink" href="#_113" title="Permanent link"></a></h4>
<ol>
<li>map和forEach的区别：map可以改变数组项，forEach不可以，也不可以用return。二者都不可以跳蛛for循环。跳出for循环可以用 for···of <code>for(let item of list)</code> ，可以使用break。es5循环有 for···in 是遍历数组下标。</li>
<li>v-for和v-if为什么不能一起使用：for的优先级比if高，每次都会遍历item再进行一次if判断</li>
<li>promise回调地狱：多个promise依次顺序执行时会出现回调地狱，可用es7的sync/await解决</li>
<li>mixins：  <ul>
<li>data或方法与组件内有冲突时： data和methods会优先取组件内，钩子函数会先执行mixins内的，再执行组件内的。</li>
<li>与普通公共方法的区别： 可以定义共用的变量，引入组建后，变量相互独立相互不影响</li>
</ul>
</li>
<li>css选择器优先级： important &gt; 内联 &gt; id &gt; 类 &gt; 标签</li>
</ol></article></body></html>